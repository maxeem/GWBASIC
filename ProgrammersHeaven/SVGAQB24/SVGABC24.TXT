






                                  REFERENCE MANUAL


                                   FOR SVGAQB.LIB


                                   AND SVGAPV.LIB


                                    THE SUPER VGA


                                  GRAPHICS LIBRARY


                                   TO BE USED WITH


                                MICROSOFT QUICKBASIC,


                                VISUAL BASIC FOR DOS


                               AND BASIC PROFESSIONAL


                                 DEVELOPMENT SYSTEM





















          1993-1996 by Zephyr Software - Stephen L. Balkum and Daniel A.
          Sill

          All rights reserved.  No part of this book shall be reproduced or
          transmitted by any means, electronic, mechanical, photocopying,
          recording or otherwise, without written permission from Zephyr
          Software - Stephen L. Balkum and Daniel A. Sill.

          Although every effort has been made to insure the accuracy of the
          material in this book, Zephyr Software, Stephen L. Balkum and
          Daniel A. Sill assume no responsibility for errors or omissions.
          In addition no liability is assumed for damages resulting from
          the use of the information contained herein.

          Printed in the United States of America

          Trademarks

          Sound Blaster and Sound Blaster Pro are trademarks of Creative
          Labs, Inc.
          All others are trademarks of their respective owners.



















                                                                         ii







                             SOFTWARE LICENSE AGREEMENT

               By using this software, you agree to the terms of this
                                     agreement.

               No warranties are expressed or implied.  In no event
               shall Zephyr Software, Stephen L. Balkum or Daniel A.
               Sill be held liable for damages resulting from the use
               or misuse of this product, including but not limited to
               implied warranties of fitness for a particular purpose.

               The shareware version may be freely distributed as long
               as all files stay together and are not modified in any
               way.  No cost may be charged for the shareware version
               beyond normal and reasonable copying and distribution
               expenses.

               No products developed with this software shall be sold
               unless this software has been registered with Zephyr
               Software, Stephen L. Balkum or Daniel A. Sill.

               At no time for any reason shall this software be
               reverse engineered, decompiled or disassembled.

               This software may not be rented or leased.

               This software may be used only on one terminal or one
               computer at any one given moment in time.  This
               software may not be installed on a network of any type.
               Contact Zephyr Software, Stephen L. Balkum or Daniel A.
               Sill for networking options.

               United States Government Restricted Rights:
               Use, duplication or disclosure of this software and
               documentation by the U.S. Government is subject to the
               restrictions as set forth in subparagraph (c)(1)(ii) of
               the Rights in Technical Data and Computer Software
               clause at DFARS 252.227-7013.  Contractor/manufacturer
               is Stephen L. Balkum and Daniel A. Sill, P.O. Box 7704,
               Austin, Texas 78713-7704.

               The ownership of this software may be transferred as
               long as Zephyr Software, Stephen L. Balkum or Daniel A.
               Sill is notified in writing of the transfer date and
               new owner.  The new owner must agree to this contract.
               The transfer must include all registered updates and
               previously registered versions.  The original owner may
               not retain any copies in any form of the registered
               software or its documents.





                                                                        iii





          INTRODUCTION

          We spent weeks searching the depths of the internet ftp sites for
          a library that would allow the programmer full access to the
          abilities of Super VGA.  We wanted the colors VGA could provide
          and better resolution than EGA could provide.  Professionally
          developed libraries with this ability were definitely out of our
          price range.  After our searches continuously returned nothing,
          we decided to fill the apparent void in the shareware market.

          Our searches did give two useful packages:  John Bridges' VGAKIT
          and Finn Thoegersen's VGADOC.  We began with these two works and
          developed a graphics library intended to allow the programmer
          access to the huge world of high resolution programming.

          On the surface the task appeared quite simple.  However, it
          quickly became obvious that the routines in this library would be
          required to affect extremely large amounts of data.  Operations
          must be quick to be successful.  Therefore, every effort was made
          to create the fastest code possible - even at the expense of
          size.  For this reason we opted to write code with the 32 bit
          instructions of the 80386 and better processors.  It is our
          opinion that anyone with a hi-res card in a lesser machine may
          have some priorities out of order. All routines are written in
          assembly and use absolutely no floating point values.  Anytime a
          real number was required, fixed point notation was used.  In
          addition we attempted to write the routines such that any
          reasonable argument passed can be interpreted intelligently by
          the library.

          With the numerous Super VGA cards available and no well
          established standard we chose John Bridges' identification and
          bank switching routines as a beginning.  These two routines have
          undergone some modification, but not enough to justify
          copyrighting this portion of the library's code by Zephyr
          Software.  We have no intentions of releasing our changes to
          these routines into the public domain.  From that point onward
          all code is original.  In some instances common algorithms were
          researched and original code written according to that algorithm.

          This Super VGA library gives the programmer transparent access to
          twenty different Super VGA cards.  These cards include Acumos,
          Ahead, ATI Technologies, Avance, Chips and Technologies, Cirrus
          Logic, Everex, Genoa, MXIC, NCR, Oak Technologies,
          Paradise/Western Digital, Primus, Realtek, Trident, Tseng Labs,
          Video 7 and the VESA standard.  Please see the WHICHVGA function
          for the specific chipsets.  The programmer only needs to verify
          that the end user's card has been identified, but not which card
          was recognized.  After proper identification, all functions react
          in exactly the same fashion.  The library contains functions to
          draw all of the major primitives.  In addition there are
          functions that modify the screen palette, write text on the
          screen with a choice of fonts and modify the reaction of the
          primitives.  Identification routines include not only the video


                                                                          2





          card, but also the amount of video memory, type of processor and
          installed pointing devices.  Advanced functions provide full
          mouse support (when used with a Microsoft compatible driver) and
          joystick support.  Finally, support for two dimensional and three
          dimensional coordinate systems is provided including rotation,
          translation, scaling and projection.


















































                                                                          3





          SUGGESTED METHODS FOR USING THIS LIBRARY

          USE WITHIN THE BASIC ENVIRONMENT

          We assume that the programmer is familiar with all of the
          capabilities of the Microsoft QuickBasic, Visual Basic (VBDOS) or
          Basic Professional Development System (PDS) compiler and
          environment.  Understanding of the LIB and LINK commands is
          encouraged as well as the use of QuickLibraries.  However, to
          ensure you are able to get up and running quickly, the following
          commands may be helpful:

          To create a QuickLibrary from SVGAQB/PV.LIB, type the command:

              LINK /QU SVGAQB/PV.LIB, SVGAQB/PV.QLB, NUL, QUICKQLB.LIB

          where QUICKQLB.LIB is the name for your compiler's QuickLibrary
          (BQLB45.LIB for QuickBasic 4.5, VBDOSQLB.LIB for VBDOS and
          QBXQLB.LIB for PDS).

          If you wish to create a QuickLibrary from SVGAQB/PV.LIB and
          additional libraries, type the command:

              LINK /QU SVGAQB/PV.LIB + ????.LIB (continue as desired),
                            NEWLIB.QLB, NUL, QUICKQLB.LIB

          where QUICKQLB.LIB is the same as above and ????.LIB represents
          the additional desired libraries.

          After the QuickLibrary has been created, you should start your
          development environment by typing:

                    QuickBasic:    QB /L SVGAQB
                    VBDOS:         VBDOS /L SVGAPV
                    PDS:           QBX /L SVGAPV

          This will tell the compiler to use the QuickLibrary when running
          and when creating an executable.

          VERIFICATION OF A COMPUTER'S HARDWARE

          It is strongly recommended that any program written with this
          library first verifies that the computer is a 80386 or better by
          calling the WHICHCPU function.  Many of the library's functions
          use 386 exclusive code which may cause a computer with a lesser
          processor to crash.  In addition WHICHMOUSE must be called before
          calling any of the mouse functions.  Lastly, it is recommended
          that WHICHJOYSTICK be called before a program uses the joystick
          routines.

          It is required that a program call WHICHVGA prior to any function
          that communicates with the video card.  If WHICHVGA returns a
          zero for unknown card type, the program should not call any
          graphics function.  Without proper identification of the video


                                                                          4





          card any graphics function will likely cause a system failure.
          It is recommended, although not necessary, that a program call
          WHICHMEM prior to calling any RES function.  Although the video
          card was properly identified, it may not have sufficient onboard
          memory to support the desired resolution.  As a second check the
          RES functions will do nothing if the video card has not been
          identified or if the video card does not support the specified
          resolution for memory or hardware reasons.

          THE 256 COLOR PALETTE

          The 256 color palette of the Super VGA cards is a six bit
          palette.  Each of the 256 colors of the palette are described by
          three values representing the intensity of the colors red, blue
          and green.  These values can range from 0 to 63.  Anytime a value
          outside of this range is used, the video card simply ignores the
          upper two bits.  Therefore, 64 is the same as 0.  This should be
          taken into consideration when manipulating the palette or when
          importing a palette from an external source such as a PCX image.

          USE OF 2-D AND 3-D FUNCTIONS

          In the interest of speed, the 2-D and 3-D functions were written
          to best work on multiple points at once.  We refer to these
          functions as object-oriented.  This means that the points
          defining an object (a box, a house, etc.) should be contained
          within one array or part of an array and calls to the functions
          should act on all of the points in the array.  Calls to functions
          have a high speed overhead, therefore, placing more than one
          object in the same array and passing the entire array to the
          functions can be beneficial.  However, these functions will work
          on a single point as well.

          A consequence of our object-oriented 2-D and 3-D functions is the
          use of the scaling functions.  When scaling objects, we recommend
          the object be defined about the origin.  D2SCALE and D3SCALE both
          work with respect to the origin.  This eliminates a significant
          number of translations that would otherwise be required by having
          a definable scale origin.  For example, to draw two boxes, one
          scaled by one-half of the other, each rotated by 45 degrees at
          the center of the screen, the recommended procedure is as
          follows:

            define an array BOX containing the 2-D points: (100, 100), (-
               100, 100), (-100, -100), (100, -100), (note: the box is
               centered about the origin.)
            rotate BOX by 45 degrees about (0, 0) and place the output in
               RBOX,
            scale RBOX by 50% (scaling factor would be 128, or 80 hex) and
               place output in SRBOX,
            translate RBOX to the center of the screen - a translation of
               320, 240 in 640x480 resolution - and place output in TRBOX,
            translate SRBOX to the center of the screen - same translation
               as for RBOX - and place output in TSRBOX,


                                                                          5





            draw TRBOX and TSRBOX on the screen.

          Notice that by defining the box centered about the origin the
          translation values were extremely intuitive.  Also notice that if
          we had scaled the second box after the translation, it would have
          been draw in the upper left quadrant of the screen instead of the
          center.

          In mathematics and many sciences it is customary that in a 2-D
          coordinate system the Y axis increases upward and the X axis
          increases to the right.  The computer industry has decided the Y
          axis should increase downward.  The 2-D functions are not
          affected by the choice in coordinate systems.  However, it is
          important to remember that a positive rotation in D2ROTATE
          rotates from the positive X axis to the positive Y axis.
          Therefore, when using mathematical conventions, a positive
          rotation moves counter-clockwise.  On the computer screen a
          positive rotation moves clockwise.

          The 3-D coordinate system follows mathematical conventions by
          using a right-handed coordinate system.  The easiest way to
          visualize this coordinate system is by using your right hand.
          Place your index finger and thumb at a right angle to one another
          as if to form an imaginary pistol.  Now place your second finger
          at a right angle to your index finger.  It should be at a right
          angle to your thumb as well.  This represents the three axes.
          The index finger is the X axis, the second finger is the Y axis
          and the thumb is the Z axis.  The easiest way to remember
          rotation directions in this system is cyclically.  A positive
          rotation about the X axis rotates the Y axis into the Z axis.  A
          positive rotation about the Y axis rotates the Z axis into the X
          axis.  A positive rotation about the Z axis rotates the X axis
          into the Y axis.

          After doing all necessary 3-D transformations, projection onto
          the 2-D computer screen is required.  Although the computer
          screen's coordinate system does not follow mathematical
          conventions, the D3PROJECT function automatically takes care of
          all conversions.  The programmer only needs to draw the resulting
          object on the screen with FILLCONVEXPOLY, FILLPOLY or a series of
          DRWLINEs.

          THE CONCEPT OF SPRITE GRAPHICS

          The key to sprite graphics is the assumption that only a small
          percentage of the pixels in a graphics block are used by the
          animation and the remaining pixels should be treated as
          transparent, revealing the background behind the sprite.  The
          sprite routines in this library only act on non-transparent
          colors, thus, saving time by ignoring a large number of pixels.
          When retrieving the background for a sprite, prior knowledge of
          the sprite itself permits obtaining background only where it is
          necessary.



                                                                          6





          The following steps outline an example of the recommended
          procedure for using the sprite functions:

            1. draw the sprite on the screen - a white stick figure on a
               black background, for example
            2. use BLKGET to place the sprite in an array STICK
            3. use SPRITEGAP to simultaneously retrieve the background into
               BACKSTICK and place STICK on the screen, declaring black as
               the transparent color
            4. use SPRITEPUT to replace the background BACKSTICK in the
               same location as step 3
            5. repeat steps 3 and 4 as many times and in as many locations
               as desired

          EXTENDED MEMORY SUPPORT

          With the higher screen resolutions, more memory may be needed for
          data storage.  For this reason extended memory support is
          provided.  Accessing extended memory requires the computer to
          switch into protected mode.  The process of switching into
          protected mode and returning is handled by the extended memory
          manager, usually HIMEM.SYS.  The switch is relatively slow.
          Therefore, it should be used as fast storage access since it is
          much faster than disk access.

          Extended memory access is also limited by the number of available
          handles.  The limit is controlled by a switch on the extended
          memory manager's command line and normally defaults to 32.  Also,
          it is imperative that all allocated extended memory blocks be
          freed before the program terminates.  Unfreed memory blocks will
          be unavailable until the computer is rebooted.

          CONVENTIONS USED IN THIS MANUAL

          All parameters, other than strings, passed to and from functions
          and procedures in this QuickBasic library are short (two byte)
          integers.  No floating point values are used.

          Whenever a pixel is written on the screen, a mode is required.
          Unless otherwise noted, there are four possible modes:  SET, XOR,
          OR and AND.  These modes are represented by the numbers one
          through four respectively.  Technically, SET is the fastest mode.
          However, XOR maybe the most useful.  XOR'ing a point twice with
          the same color returns the original color.  This can be used to
          cover and uncover graphics.  In addition when a reference to a
          color index is made, only values between and including 0 and 255
          are valid.  Any integer will work, but only the lowest eight bits
          are recognized.








                                                                          7





          BLKGET

            PROTOTYPE

            SUB BLKGET (X1%, Y1%, X2%, Y2%, GfxBlk%)

            INPUT

            X1, Y1 - top left corner of block
            X2, Y2 - bottom right corner of block

            OUTPUT

            If declared as a function, BLKGET returns 1 if successful, 0
            if failed.
            GfxBlk - integer destination array holding retrieved bitmap

            USAGE

            BLKGET stores the pixel data contained within the block
            defined by (X1, Y1)-(X2, Y2) in the variable referenced by
            GfxBlk.  GfxBlk must be dimensioned as a short integer array
            with a size in integers equal to
                             [(X2-X1+1)*(Y2-Y1+1)] / 2+3.
            Note, however, that GfxBlk can be quite large.  If the size of
            GfxBlk is insufficient, BLKGET will overwrite any data in
            memory contained beyond GfxBlk and may possibly cause the
            system to crash.  BLKGET enforces X2 X1 and Y2Y1.  Also, the
            coordinates must be valid on the screen at the current
            resolution.

            The bitmap is stored such that the first integer in the
            destination array is the width and the second integer is the
            height.  The remaining bytes are the bitmap raster data stored
            by rows starting at the top of the block.

            Arrays should be passed by giving the element within the array
            from where the action should take place.  This allows the
            programmer to store more than one item within the same array
            or act on only a portion of the array.

            SEE ALSO

            BLKPUT, BLKRESIZE, BLKROTATE, GETLASTSTRING, SPRITEGAP,
            SPRITEGET, SPRITEPUT, XMSBLKGET, XMSBLKPUT

            EXAMPLE

            REM PLACES 1/4 OF A CIRCLE AT THE CENTER OF THE SCREEN
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z
            DIM BLOCKDATA(0 TO 483) AS INTEGER
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640


                                                                          8





            DRWCIRCLE 1, 10, 30, 30, 20
            FILLAREA 30, 30, 10, 7
            BLKGET 0, 0, 30, 30, BLOCKDATA(0)
            BLKPUT 1, 320, 240, BLOCKDATA(0)
            WHILE INKEY$ = ""
            WEND
            DUMMY=RESTEXT
            END
















































                                                                          9





          BLKPUT

            PROTOTYPE

            SUB BLKPUT (Mode%, X%, Y%, GfxBlk%)

            INPUT

            Mode - pixel write mode (SET=1, XOR=2, OR=3, AND=4)
            X, Y - location for top left corner of block
            GfxBlk - integer source array

            OUTPUT

            no value returned

            USAGE

            BLKPUT places the pixel data contained in the variable
            referenced by GfxBlk on the screen.  The top, left corner of
            the block is specified by (X, Y).  Any (X, Y) is acceptable
            and any portion of the block that lies outside of the
            currently defined viewport will not be drawn.

            Arrays should be passed by giving the element within the array
            from where the action should take place.  This allows the
            programmer to store more than one item within the same array
            or act on only a portion of the array.

            SEE ALSO

            BLKGET, BLKRESIZE, BLKROTATE, GETLASTSTRING, SPRITEGAP,
            SPRITEGET, SPRITEPUT, PCXPUT, SETVIEW, XMSBLKGET, XMSBLKPUT

            EXAMPLE

            See BLKGET



















                                                                         10





          BLKRESIZE

            PROTOTYPE

            SUB BLKRESIZE (NewXSize%, NewYSize%, SourceGfxBlk%,
            DestGfxBlk%)

            INPUT

            NewXSize, NewYSize - size of resulting bitmap in DestGfxBlk
            SourceGfxBlk - integer source array

            OUTPUT

            no value returned
            DestGfxBlk - integer destination array holding resized bitmap

            USAGE

            BLKRESIZE takes the bitmap in SourceGfxBlk and scales it up or
            down according the to values passed in NewXSize and NewYSize.
            The resulting bitmap is returned in DestGfxBlk which should
            already be declared with a size calculated according to the
            equation in BLKGET.  NewXSize and NewYSize should not be zero.

            SEE ALSO

            BLKGET, BLKPUT, BLKROTATE

            EXAMPLE

            REM  RESIZE A BITMAP
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z
            DIM SRC%(0 TO 32000)
            DIM DST%(0 TO 32000)

            IF WHICHCPU < 386 THEN END
            IF WHICHVGA = 0 THEN END
            VMODE=VIDEOMODEGET
            IF RES640 <> 1 THEN
                DUMMY = RESTEXT
                END
            END IF
            X1 = 0
            Y1 = 0
            X2 = 50
            Y2 = 50
            FOR I = 0 TO 25
                XA = (RND * X2 - X1) + X1
                YA = (RND * Y2 - Y1) + Y1
                XB = (RND * X2 - X1) + X1
                YB = (RND * Y2 - Y1) + Y1
                C = RND * 16


                                                                         11





                DRWLINE 1, C, XA, YA, XB, YB
            NEXT I
            DRWBOX 1, 15, X1, Y1, X2, Y2
            BLKGET X1, Y1, X2, Y2, SRC(0)
            X1 = GETMAXX \ 2
            Y1 = GETMAXY \ 2
            X = SRC(0) + 1
            Y = SRC(1) + 1
            BLKRESIZE X, Y, SRC(0), DST(0)
            BLKPUT 2, X1 - DST(0) \ 2, Y1 - DST(1) \ 2, DST(0)
            FOR I = X TO X + 50
                BLKPUT 2, X1 - DST(0) \ 2, Y1 - DST(1) \ 2, DST(0)
                BLKRESIZE I, I, SRC(0), DST(0)
                BLKPUT 2, X1 - DST(0) \ 2, Y1 - DST(1) \ 2, DST(0)
                SDELAY 3
            NEXT I
            FOR I = X + 50 TO X - 50 STEP -1
                BLKPUT 2, X1 - DST(0) \ 2, Y1 - DST(1) \ 2, DST(0)
                BLKRESIZE I, I, SRC(0), DST(0)
                BLKPUT 2, X1 - DST(0) \ 2, Y1 - DST(1) \ 2, DST(0)
                SDELAY 3
            NEXT I
            FOR I = X - 50 TO X
                BLKPUT 2, X1 - DST(0) \ 2, Y1 - DST(1) \ 2, DST(0)
                BLKRESIZE I, I, SRC(0), DST(0)
                BLKPUT 2, X1 - DST(0) \ 2, Y1 - DST(1) \ 2, DST(0)
                SDELAY 3
            NEXT I
            VIDEOMODESET VMODE
            END


























                                                                         12





          BLKROTATE

            PROTOTYPE

            FUNCTION BLKROTATE% (Ang%, BackFillColor%, SourceGfxBlk%,
            DestGfxBlk%)

            INPUT

            Ang - integer degree to rotate source bitmap
            BackFillColor - index to color in current palette to fill
            blank space in DestGfxBlk
            SourceGfxBlk - integer source array

            OUTPUT

            BLKROTATE returns 1 if successful, 0 if unsuccessful.
            DestGfxBlk - integer destination array holding rotated bitmap

            USAGE

            BLKROTATE takes the bitmap in SourceGfxBlk and rotates by the
            number of degrees specified in Ang.  The bitmap rotation
            algorithm is a three-pass shear technique modified to make
            efficient use of this library's internal buffers.  Blank space
            around the newly rotated block is filled with the color given
            by BackFillColor.  The resulting bitmap is stored in
            DestGfxBlk.  The size of DestGfxBlk should be at least as big
            as given by BLKROTATESIZE.

            The function will fail if it calculates that the internal
            buffers would be overflowed or if the destination array would
            be larger than 65536 bytes.  BLKROTATESIZE should be called
            first to ensure that buffer integrity is maintained.

            SEE ALSO

            BLKGET, BLKPUT, BLKRESIZE, BLKROTATESIZE

            EXAMPLE

            REM ROTATE A BITMAP
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z
            DIM SRC%(0 TO 32000)
            DIM DST%(0 TO 32000)
            IF WHICHCPU < 386 THEN END
            IF WHICHVGA = 0 THEN END
            VMODE = VIDEOMODEGET
            IF RES640 <> 1 THEN
                DUMMY = RESTEXT
                END
            END IF
            X1 = 0


                                                                         13





            Y1 = 0
            X2 = 110
            Y2 = 110
            FOR I = 0 TO 50
                XA = (RND * X2 - X1) + X1
                YA = (RND * Y2 - Y1) + Y1
                XB = (RND * X2 - X1) + X1
                YB = (RND * Y2 - Y1) + Y1
                C = RND * 16
                DRWLINE 1, C, XA, YA, XB, YB
            NEXT I
            DRWBOX 1, 15, X1, Y1, X2, Y2
            BLKGET X1, Y1, X2, Y2, SRC(0)
            X1 = GETMAXX \ 2
            Y1 = GETMAXY \ 2
            FOR I = 0 TO 359 STEP 6
                IF BLKROTATESIZE(I, SRC(0)) <> 0 THEN
                 DUMMY = BLKROTATE(I, 0, SRC(0), DST(0))
                 BLKPUT 2, X1 - DST(0) \ 2, Y1 - DST(1) \ 2, DST(0)
                 SDELAY 3
                 BLKPUT 2, X1 - DST(0) \ 2, Y1 - DST(1) \ 2, DST(0)
                END IF
            NEXT I
            VIDEOMODESET VMODE
            END































                                                                         14





          BLKROTATESIZE

            PROTOTYPE

            FUNCTION BLKROTATESIZE& (Ang%, SourceGfxBlk%)

            INPUT

            Ang - integer degree to rotate source bitmap
            SourceGfxBlk - integer source array

            OUTPUT

            BLKROTATESIZE returns the number of bytes needed for the
            destination array if successful, 0 if unsuccessful.

            USAGE

            BLKROTATESIZE takes the bitmap in SourceGfxBlk calculates the
            required size of the output buffer needed when BLKROTATE is
            called.  It also insures that the internal library buffers are
            not overflowed.  The function will fail if it calculates that
            the internal buffers would be overflowed or if the destination
            array would be larger than 65536 bytes.  BLKROTATESIZE should
            be called prior to BLKROTATE to ensure that buffer integrity
            is maintained.

            SEE ALSO

            BLKGET, BLKPUT, BLKRESIZE, BLKROTATE

            EXAMPLE

            See BLKROTATE






















                                                                         15





          BYTECOPY

            PROTOTYPE

            SUB BYTECOPY (Source AS ANY, Dest AS ANY, NumOfBytes&)

            INPUT

            Source - integer array to be copied
            NumBytes - number of bytes to copy from Source to Dest

            OUTPUT

            no value returned
            Dest - integer destination array holding copied data

            USAGE

            BYTECOPY copies the specified number of bytes from Source to
            Dest.  It is much faster than using a FOR/NEXT loop.  NumBytes
            is equal to the number of bytes to be copied.  For example, if
            Source contains 10 integers to be copied, NumBytes is 2 * 10,
            or 20 bytes.  The declaration for BYTECOPY permits any
            variable type to be copied.  However, BYTECOPY will not work
            with strings.  It will copy strings contained with a user
            defined type.  Remember that real numbers and long integers
            are 4 bytes.

            Arrays should be passed by giving the element within the array
            from where the action should take place.  This allows the
            programmer to store more than one item within the same array
            or act on only a portion of the array.

            SEE ALSO

            PALCOPY

            EXAMPLE

            REM SHOW HOW BYTE COPY WORKS ON MANY DATA TYPES
            REM REMEBER: INTEGER=2 BYTES; LONG INTEGER=4 BYTES;
            REM SINGLE REAL=4 BYTES; LONG REAL=8 BYTES; USER DEFINED
            REM VARIABLES MUST BE CACULATED BY THEIR INDIVIDUAL PARTS;
            REM $INCLUDE: 'SVGABC.BI'

            TYPE MyType
               CustNum AS INTEGER
               CustAmnt AS SINGLE
               CustName AS STRING * 20
            END TYPE

            DEFINT A-Z

            DIM CA(0 TO 1) AS MyType


                                                                         16





            DIM CB(0 TO 1) AS MyType
            DIM IntAryA(0 TO 2) AS INTEGER
            DIM IntAryB(0 TO 2) AS INTEGER
            DIM SingleAry(0 TO 5) AS SINGLE
            DIM LongAryA(0 TO 2) AS LONG
            DIM LongAryB(0 TO 2) AS LONG
            DIM LongRealAryA(0 TO 2) AS DOUBLE
            DIM LongRealAryB(0 TO 2) AS DOUBLE

            FOR I = 0 TO 1
               READ CA(I).CustNum
               READ CA(I).CustAmnt
               READ CA(I).CustName
            NEXT I
            FOR I = 0 TO 2
               READ IntAryA(I)
            NEXT I
            FOR I = 0 TO 2
               READ SingleAry(I)
            NEXT I
            FOR I = 0 TO 2
               READ LongAryA(I)
            NEXT I
            FOR I = 0 TO 2
               READ LongRealAryA(I)
            NEXT I

            REM HERE WE DO THE COPIES
            BYTECOPY CA(0), CB(0), 48
            BYTECOPY IntAryA(0), IntAryB(0), 6
            BYTECOPY SingleAry(0), SingleAry(3), 12
            BYTECOPY LongAryA(0), LongAryB(0), 12
            BYTECOPY LongRealAryA(0), LongRealAryB(0), 24

            PRINT "-------HERE ARE USER DEFINED ARRAYS:-------"
            FOR I = 0 TO 1
               PRINT CA(I).CustName; TAB(40); CB(I).CustName
               PRINT CA(I).CustNum; TAB(40); CB(I).CustNum
               PRINT CA(I).CustAmnt; TAB(40); CB(I).CustAmnt
            NEXT I
            PRINT "------HERE ARE SHORT INTEGER ARRAYS:-------"
            FOR I = 0 TO 2
               PRINT IntAryA(I); TAB(40); IntAryB(I)
            NEXT I
            PRINT "-------HERE ARE SHORT REAL ARRAYS:---------"
            FOR I = 0 TO 2
               PRINT SingleAry(I); TAB(40); SingleAry(I + 3)
            NEXT I
            PRINT "-------HERE ARE LONG INTEGER ARRAYS:-------"
            FOR I = 0 TO 2
               PRINT LongAryA(I); TAB(40); LongAryB(I)
            NEXT I
            PRINT "-------HERE ARE LONG REAL ARRAYS:----------"
            FOR I = 0 TO 2


                                                                         17





               PRINT LongRealAryA(I); TAB(40); LongRealAryB(I)
            NEXT I
            WHILE INKEY$ = ""
            WEND

            REM CUSTOMER DATA
            DATA 102,120.98,"John Doe"
            DATA 182,160.23,"Jane Smith"

            REM INTEGER DATA
            DATA 2,62,9456

            REM SINGLE REAL DATA
            DATA 1.23,45.342,13.13

            REM LONG INTEGER DATA
            DATA 45000,92538,101234

            REM LONG REAL DATA
            DATA 345.45345,834.923734,485344.456




































                                                                         18





          D2ROTATE

            PROTOTYPE

            SUB D2ROTATE (NumPoints%, XOrigin%, YOrigin%, Angle%,
            InArray%, OutArray%)

            INPUT

            NumPoints - number of points to be rotated
            Xorigin, Yorigin - center of rotation
            Angle - angle of rotation about center
            InArray - P2DType array containing points to rotate

            OUTPUT

            no value returned
            OutArray - P2DType array holding rotated values

            USAGE

            D2ROTATE takes the two dimensional points given in InArray and
            rotates them by the specified angle about Xorigin, Yorigin.
            The results are returned in OutArray which can be the same as
            InArray.  A positive angle causes a clockwise rotation on the
            screen, from the positive X axis to the positive Y axis.

            Arrays should be passed by giving the element within the array
            from where the action should take place.  This allows the
            programmer to store more than one item within the same array
            or act on only a portion of the array.

            SEE ALSO

            D2SCALE, D2TRANSLATE

            EXAMPLE

            REM ROTATE A TRIANGLE ABOUT ONE CORNER
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z
            DIM TRIO(1 TO 3) AS P2DType
            DIM TRI(1 TO 3) AS P2DType
            DIM TRI2(1 TO 3) AS P2DType

            TRIO(1).X = 0
            TRIO(1).Y = 0
            TRIO(2).X = -80
            TRIO(2).Y = 60
            TRIO(3).X = 80
            TRIO(3).Y = 60
            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640


                                                                         19





            GOSUB DRWTRI
            FOR I = 0 TO 360 STEP 2
            D2ROTATE 3, 0, 0, I, TRIO(1).X, TRI(1).X
            GOSUB DRWTRI
            SDELAY 2
            GOSUB ERTRI
            NEXT I
            GOSUB DRWTRI
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END

            DRWTRI:
            D2TRANSLATE 3, 320, 240, TRI(1).X, TRI2(1).X
            DRWLINE 1, 10, TRI2(1).X, TRI2(1).Y, TRI2(2).X, TRI2(2).Y
            DRWLINE 1, 10, TRI2(2).X, TRI2(2).Y, TRI2(3).X, TRI2(3).Y
            DRWLINE 1, 10, TRI2(3).X, TRI2(3).Y, TRI2(1).X, TRI2(1).Y
            RETURN

            ERTRI:
            D2TRANSLATE 3, 320, 240, TRI(1).X, TRI2(1).X
            DRWLINE 1, 0, TRI2(1).X, TRI2(1).Y, TRI2(2).X, TRI2(2).Y
            DRWLINE 1, 0, TRI2(2).X, TRI2(2).Y, TRI2(3).X, TRI2(3).Y
            DRWLINE 1, 0, TRI2(3).X, TRI2(3).Y, TRI2(1).X, TRI2(1).Y
            RETURN






























                                                                         20





          D2SCALE

            PROTOTYPE

            SUB D2SCALE (NumPoints%, ScaleX%, ScaleY%, InArray%,
            OutArray%)

            INPUT

            NumPoints - number of points to scale
            ScaleX - scale factor along X axis
            ScaleY - scale factor along Y axis
            InArray - P2DType array containing points to scale

            OUTPUT

            no value returned
            OutArray - P2DType array holding scaled values

            USAGE

            D2SCALE multiplies each coordinate in the two dimensional
            array InArray by the corresponding scale factor ScaleX or
            ScaleY.  The results are stored in OutArray which can be the
            same as InArray.  A scale factor of 256 (100 hex) is
            considered 100 percent and results in no change.  Therefore,
            128 (80 hex) reduces values by one half and 512 (200 hex)
            doubles values.

            Arrays should be passed by giving the element within the array
            from where the action should take place.  This allows the
            programmer to store more than one item within the same array
            or act on only a portion of the array.

            SEE ALSO

            D2ROTATE, D2TRANSLATE

            EXAMPLE

            REM SCALE A TRIANGLE
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z
            DIM TRIO(1 TO 3) AS P2DType
            DIM TRI(1 TO 3) AS P2DType
            DIM TRI2(1 TO 3) AS P2DType

            TRIO(1).X = 0
            TRIO(1).Y = 0
            TRIO(2).X = -80
            TRIO(2).Y = 60
            TRIO(3).X = 80
            TRIO(3).Y = 60
            VMODE = VIDEOMODEGET


                                                                         21





            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            GOSUB DRWTRI
            FOR I = 256 TO 512 STEP 4
            D2SCALE 3, I, I, TRIO(1).X, TRI(1).X
            GOSUB DRWTRI
            SDELAY 2
            GOSUB ERTRI
            NEXT I
            FOR I = 512 TO 128 STEP -4
            D2SCALE 3, I, I, TRIO(1).X, TRI(1).X
            GOSUB DRWTRI
            SDELAY 2
            GOSUB ERTRI
            NEXT I

            FOR I = 128 TO 256 STEP 4
            D2SCALE 3, I, I, TRIO(1).X, TRI(1).X
            GOSUB DRWTRI
            SDELAY 2
            GOSUB ERTRI
            NEXT I
            GOSUB DRWTRI
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END

            DRWTRI:
            D2TRANSLATE 3, 320, 240, TRI(1).X, TRI2(1).X
            DRWLINE 1, 10, TRI2(1).X, TRI2(1).Y, TRI2(2).X, TRI2(2).Y
            DRWLINE 1, 10, TRI2(2).X, TRI2(2).Y, TRI2(3).X, TRI2(3).Y
            DRWLINE 1, 10, TRI2(3).X, TRI2(3).Y, TRI2(1).X, TRI2(1).Y
            RETURN

            ERTRI:
            D2TRANSLATE 3, 320, 240, TRI(1).X, TRI2(1).X
            DRWLINE 1, 0, TRI2(1).X, TRI2(1).Y, TRI2(2).X, TRI2(2).Y
            DRWLINE 1, 0, TRI2(2).X, TRI2(2).Y, TRI2(3).X, TRI2(3).Y
            DRWLINE 1, 0, TRI2(3).X, TRI2(3).Y, TRI2(1).X, TRI2(1).Y
            RETURN















                                                                         22





          D2TRANSLATE

            PROTOTYPE

            SUB D2TRANSLATE (NumPoints%, TransX%, TransY%, InArray%,
            OutArray%)

            INPUT

            NumPoints - number of points to be translated
            TransX - distance to translate along X axis
            TransY - distance to translate along Y axis
            InArray - P2DType array containing points to translate

            OUTPUT

            no value returned
            OutArray - P2DType array holding translated values

            USAGE

            D2TRANSLATE takes the two dimensional points given in InArray
            and translates them by the specified number of pixels along
            each axis.  The results are returned in OutArray which can be
            the same as InArray.

            Arrays should be passed by giving the element within the array
            from where the action should take place.  This allows the
            programmer to store more than one item within the same array
            or act on only a portion of the array.

            SEE ALSO

            D2ROTATE, D2SCALE

            EXAMPLE

            REM TRANSLATE A TRIANGLE
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z
            DIM TRIO(1 TO 3) AS P2DType
            DIM TRI(1 TO 3) AS P2DType
            DIM TRI2(1 TO 3) AS P2DType

            TRIO(1).X = 0
            TRIO(1).Y = 0
            TRIO(2).X = -80
            TRIO(2).Y = 60
            TRIO(3).X = 80
            TRIO(3).Y = 60
            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            GOSUB DRWTRI


                                                                         23





            FOR I = 0 TO 100 STEP 4
            D2TRANSLATE 3, I, I, TRIO(1).X, TRI(1).X
            GOSUB DRWTRI
            SDELAY 2
            GOSUB ERTRI
            NEXT I
            FOR I = 100 TO 0 STEP -4
            D2TRANSLATE 3, I, I, TRIO(1).X, TRI(1).X
            GOSUB DRWTRI
            SDELAY 2
            GOSUB ERTRI
            NEXT I
            GOSUB DRWTRI
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END

            DRWTRI:
            D2TRANSLATE 3, 320, 240, TRI(1).X, TRI2(1).X
            DRWLINE 1, 10, TRI2(1).X, TRI2(1).Y, TRI2(2).X, TRI2(2).Y
            DRWLINE 1, 10, TRI2(2).X, TRI2(2).Y, TRI2(3).X, TRI2(3).Y
            DRWLINE 1, 10, TRI2(3).X, TRI2(3).Y, TRI2(1).X, TRI2(1).Y
            RETURN

            ERTRI:
            D2TRANSLATE 3, 320, 240, TRI(1).X, TRI2(1).X
            DRWLINE 1, 0, TRI2(1).X, TRI2(1).Y, TRI2(2).X, TRI2(2).Y
            DRWLINE 1, 0, TRI2(2).X, TRI2(2).Y, TRI2(3).X, TRI2(3).Y
            DRWLINE 1, 0, TRI2(3).X, TRI2(3).Y, TRI2(1).X, TRI2(1).Y
            RETURN

























                                                                         24





          D3PROJECT

            PROTOTYPE

            FUNCTION D3PROJECT% (NumPoints%, ProjParams%, InArray%,
            OutArray%)

            INPUT

            NumPoints - number of points to be projected
            ProjParams - PROJType structure containing parameters used in
            projection
               EyeX, EyeY, EyeZ - 3D location of viewer
               ScrD - distance from viewer to projection screen
               Theta - angle from positive 3D X axis to viewing direction
               Phi - angle from positive 3D Z axis to viewing direction
            InArray - P3DType array containing points to project

            OUTPUT

            D3PROJECT returns 1 if successful, 0 if any one point failed.
            OutArray - P2DType array holding projected values

            USAGE
                                +Z axis
                                   |                   /\
                                   |                  /  \
                                   |            !     \ * \
                                   |            !......X: /
                                   |            ! Phi / \/
                                   |            !    /  :
                                   |            !   /   :
                                   |            !  /    :
                                   |       EyeX ! /ScrD :
                                   |       EyeY !/      :
                                   |       EyeZ *- - - -:- - - - -
                                   |           / `      :
                                   |          /   `     :
                                   |         /      `   :
                                   |        /      ---` :
                                   |       /___----
                                   |      /     Theta
                                   |
                                   |_____________________________+Y axis
                                   /
                                  /
                                 /
                                /
                               /
                              /
                             /
                         +X axis




                                                                         25





            D3PROJECT projects a specified number, NumPoints, of three
            dimensional points starting at InArray into two dimensions
            according to the parameters in ProjParams.  The two
            dimensional points are stored in OutArray.  The location of
            the viewer in this three dimensional space is given by EyeX,
            EyeY, EyeZ in the ProjParams structure.  The direction the
            viewer is facing is specified with ScrD, Theta, Phi in the
            ProjParams structure using spherical coordinates.  A virtual
            set of axes parallel to the true axes are placed at the
            viewer's location.  ScrD is the distance from the viewer to
            the center of the projection screen, i.e. the currently
            defined viewport on the monitor's screen.  Theta is the angle
            in the virtual X-Y plane from the virtual X axis to the
            projection screen.  Positive angles rotate counter-clockwise
            in the X-Y plane.  Lastly, the angle of elevation above or
            below the virtual X-Y plane is given by Phi.  Positive angles
            direct viewing above the plane; negative below.

            If a point is projected to a location behind the viewer, i.e.
            on the side of the viewer opposite the projection screen,
            D3PROJECT returns a zero indicating one or more failed points.
            The returned values of the X and Y for failed points will be -
            32768 to make them easily identified.

            Arrays should be passed by giving the element within the array
            from where the action should take place.  This allows the
            programmer to store more than one item within the same array
            or act on only a portion of the array.

            SEE ALSO

            D3ROTATE, D3TRANSLATE, D3SCALE, FILLCONVEXPOLY, FILLPOLY,
            SETVIEW

            EXAMPLE

            REM DRAW A CUBE AT THE CENTER OF THE SCREEN
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z
            DIM CUBE(1 TO 8) AS P3DType
            DIM PLOT(1 TO 8) AS P2DType
            DIM PROJPARAMS AS PROJType

            CUBE(1).X =  100 : CUBE(1).Y = -100 : CUBE(1).Z =  100
            CUBE(2).X =  100 : CUBE(2).Y = -100 : CUBE(2).Z = -100
            CUBE(3).X =  100 : CUBE(3).Y =  100 : CUBE(3).Z = -100
            CUBE(4).X =  100 : CUBE(4).Y =  100 : CUBE(4).Z =  100
            CUBE(5).X = -100 : CUBE(5).Y = -100 : CUBE(5).Z =  100
            CUBE(6).X = -100 : CUBE(6).Y = -100 : CUBE(6).Z = -100
            CUBE(7).X = -100 : CUBE(7).Y =  100 : CUBE(7).Z = -100
            CUBE(8).X = -100 : CUBE(8).Y =  100 : CUBE(8).Z =  100
            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640


                                                                         26





            PROJPARAMS.EYEX = -1040
            PROJPARAMS.EYEY = -600
            PROJPARAMS.EYEZ = -1200
            PROJPARAMS.SCRD = 1700
            PROJPARAMS.THETA = 30
            PROJPARAMS.PHI = 45
            DUMMY = D3PROJECT(8,PROJPARAMS.EYEX,CUBE(1).X,PLOT(1).X)
            GOSUB DRWCUBE
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END

            DRWCUBE:
            FOR J=1 TO 3
            DRWLINE 1, 10, PLOT(J).X, PLOT(J).Y, PLOT(J+1).X, PLOT(J+1).Y
            NEXT J
            DRWLINE 1, 10, PLOT(4).X, PLOT(4).Y, PLOT(1).X, PLOT(1).Y
            FOR J=5 TO 7
            DRWLINE 1, 10, PLOT(J).X, PLOT(J).Y, PLOT(J+1).X, PLOT(J+1).Y
            NEXT J
            DRWLINE 1, 10, PLOT(8).X, PLOT(8).Y, PLOT(5).X, PLOT(5).Y
            FOR J=1 TO 4
            DRWLINE 1, 10, PLOT(J).X, PLOT(J).Y, PLOT(J+4).X, PLOT(J+4).Y
            NEXT J
            RETURN






























                                                                         27





          D3ROTATE

            PROTOTYPE

            SUB D3ROTATE (NumPoints%, X%, Y%, Z%, AngleZ%, AngleY%,
            AngleX%, InArray%, OutArray%)

            INPUT

            NumPoints - number of points to be rotated
            X, Y, Z - center of rotation
            AngleZ - angle of rotation about the Z axis
            AngleY - angle of rotation about the Y axis
            AngleX - angle of rotation about the X axis
            InArray - P3DType array containing points to rotate

            OUTPUT

            no value returned
            OutArray - P3DType array holding rotated values

            USAGE

            D3ROTATE takes the three dimensional points given in InArray
            and rotates them by the specified angles about Xorigin,
            Yorigin, Zorigin.  The results are returned in OutArray which
            can be the same as InArray.  A virtual set of axes are placed
            at the origin of rotation and rotation takes place about these
            axes.  A positive angle causes a counter-clockwise rotation
            from the positive X axis to the positive Y axis.

            Arrays should be passed by giving the element within the array
            from where the action should take place.  This allows the
            programmer to store more than one item within the same array
            or act on only a portion of the array.

            SEE ALSO

            D3PROJECT, D3SCALE, D3TRANSLATE

            EXAMPLE

            REM ROTATE A CUBE AT THE CENTER OF THE SCREEN
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z
            DIM CUBE(1 TO 8) AS P3DType
            DIM RCUBE(1 TO 8) AS P3DType
            DIM PLOT(1 TO 8) AS P2DType
            DIM PROJPARAMS AS PROJType

            CUBE(1).X =  100 : CUBE(1).Y = -100 : CUBE(1).Z =  100
            CUBE(2).X =  100 : CUBE(2).Y = -100 : CUBE(2).Z = -100
            CUBE(3).X =  100 : CUBE(3).Y =  100 : CUBE(3).Z = -100
            CUBE(4).X =  100 : CUBE(4).Y =  100 : CUBE(4).Z =  100


                                                                         28





            CUBE(5).X = -100 : CUBE(5).Y = -100 : CUBE(5).Z =  100
            CUBE(6).X = -100 : CUBE(6).Y = -100 : CUBE(6).Z = -100
            CUBE(7).X = -100 : CUBE(7).Y =  100 : CUBE(7).Z = -100
            CUBE(8).X = -100 : CUBE(8).Y =  100 : CUBE(8).Z =  100
            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            PROJPARAMS.EYEX = -1040
            PROJPARAMS.EYEY = -600
            PROJPARAMS.EYEZ = -1200
            PROJPARAMS.SCRD = 1700
            PROJPARAMS.THETA = 30
            PROJPARAMS.PHI = 45
            FOR I = 0 TO 360 STEP 5
            D3ROTATE 8, 0, 0, 0, I, I, I, CUBE(1).X, RCUBE(1).X
            DUMMY = D3PROJECT(8,PROJPARAMS.EYEX,RCUBE(1).X,PLOT(1).X)
            GOSUB DRWCUBE
            SDELAY 2
            GOSUB DRWCUBE
            NEXT I
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END

            DRWCUBE:
            FOR J=1 TO 3
            DRWLINE 2, 10, PLOT(J).X, PLOT(J).Y, PLOT(J+1).X, PLOT(J+1).Y
            NEXT J
            DRWLINE 2, 10, PLOT(4).X, PLOT(4).Y, PLOT(1).X, PLOT(1).Y
            FOR J=5 TO 7
            DRWLINE 2, 10, PLOT(J).X, PLOT(J).Y, PLOT(J+1).X, PLOT(J+1).Y
            NEXT J
            DRWLINE 2, 10, PLOT(8).X, PLOT(8).Y, PLOT(5).X, PLOT(5).Y
            FOR J=1 TO 4
            DRWLINE 2, 10, PLOT(J).X, PLOT(J).Y, PLOT(J+4).X, PLOT(J+4).Y
            NEXT J
            RETURN


















                                                                         29





          D3SCALE

            PROTOTYPE

            SUB D3SCALE (NumPoints%, ScaleX%, ScaleY%, ScaleZ%, InArray%,
            OutArray%)

            INPUT

            NumPoints - number of points to scale
            ScaleX - scale factor along X axis
            ScaleY - scale factor along Y axis
            ScaleZ - scale factor along Z axis
            InArray - P3DType array containing points to scale

            OUTPUT

            no value returned
            OutArray - P3DType array holding scaled values

            USAGE

            D3SCALE multiplies each coordinate in the three dimensional
            array InArray by the corresponding scale factor ScaleX, ScaleY
            or ScaleZ.  The results are stored in OutArray which can be
            the same as InArray.  A scale factor of 256 (100 hex) is
            considered 100 percent and results in no change.  Therefore,
            128 (80 hex) reduces values by one half and 512 (200 hex)
            doubles values.

            Arrays should be passed by giving the element within the array
            from where the action should take place.  This allows the
            programmer to store more than one item within the same array
            or act on only a portion of the array.

            SEE ALSO

            D3PROJECT, D3ROTATE, D3TRANSLATE

            EXAMPLE

            REM SCALE A CUBE AT THE CENTER OF THE SCREEN
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z
            DIM CUBE(1 TO 8) AS P3DType
            DIM SCUBE(1 TO 8) AS P3DType
            DIM PLOT(1 TO 8) AS P2DType
            DIM PROJPARAMS AS PROJType

            CUBE(1).X =  100 : CUBE(1).Y = -100 : CUBE(1).Z =  100
            CUBE(2).X =  100 : CUBE(2).Y = -100 : CUBE(2).Z = -100
            CUBE(3).X =  100 : CUBE(3).Y =  100 : CUBE(3).Z = -100
            CUBE(4).X =  100 : CUBE(4).Y =  100 : CUBE(4).Z =  100
            CUBE(5).X = -100 : CUBE(5).Y = -100 : CUBE(5).Z =  100


                                                                         30





            CUBE(6).X = -100 : CUBE(6).Y = -100 : CUBE(6).Z = -100
            CUBE(7).X = -100 : CUBE(7).Y =  100 : CUBE(7).Z = -100
            CUBE(8).X = -100 : CUBE(8).Y =  100 : CUBE(8).Z =  100
            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            PROJPARAMS.EYEX = -1040
            PROJPARAMS.EYEY = -600
            PROJPARAMS.EYEZ = -1200
            PROJPARAMS.SCRD = 1700
            PROJPARAMS.THETA = 30
            PROJPARAMS.PHI = 45
            FOR I = 256 TO 128 STEP -4
            D3SCALE 8, I, I, I, CUBE(1).X, SCUBE(1).X
            DUMMY = D3PROJECT(8,PROJPARAMS.EYEX,SCUBE(1).X,PLOT(1).X)
            GOSUB DRWCUBE
            SDELAY 2
            GOSUB DRWCUBE
            NEXT I
            FOR I = 132 TO 256 STEP 4
            D3SCALE 8, I, I, I, CUBE(1).X, SCUBE(1).X
            DUMMY = D3PROJECT(8,PROJPARAMS.EYEX,SCUBE(1).X,PLOT(1).X)
            GOSUB DRWCUBE
            SDELAY 2
            GOSUB DRWCUBE
            NEXT I
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END

            DRWCUBE:
            FOR J=1 TO 3
            DRWLINE 2, 10, PLOT(J).X, PLOT(J).Y, PLOT(J+1).X, PLOT(J+1).Y
            NEXT J
            DRWLINE 2, 10, PLOT(4).X, PLOT(4).Y, PLOT(1).X, PLOT(1).Y
            FOR J=5 TO 7
            DRWLINE 2, 10, PLOT(J).X, PLOT(J).Y, PLOT(J+1).X, PLOT(J+1).Y
            NEXT J
            DRWLINE 2, 10, PLOT(8).X, PLOT(8).Y, PLOT(5).X, PLOT(5).Y
            FOR J=1 TO 4
            DRWLINE 2, 10, PLOT(J).X, PLOT(J).Y, PLOT(J+4).X, PLOT(J+4).Y
            NEXT J
            RETURN












                                                                         31





          D3TRANSLATE

            PROTOTYPE

            SUB D3TRANSLATE (NumPoints%, TransX%, TransY%, TransZ%,
            InArray%, OutArray%)

            INPUT

            NumPoints - number of points to translate
            TransX - distance to translate along X axis
            TransY - distance to translate along Y axis
            TransZ - distance to translate along Z axis
            InArray - P3DType array containing points to translate

            OUTPUT

            no value returned
            OutArray - P3DType array holding translated points

            USAGE

            D3TRANSLATE takes the three dimensional points given in
            InArray and translates them by the specified number of pixels
            along each axis.  The results are returned in OutArray which
            can be the same as InArray.

            Arrays should be passed by giving the element within the array
            from where the action should take place.  This allows the
            programmer to store more than one item within the same array
            or act on only a portion of the array.

            SEE ALSO

            D3PROJECT, D3ROTATE, D3SCALE

            EXAMPLE

            REM TRANSLATE A CUBE NEAR THE CENTER OF THE SCREEN
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z
            DIM CUBE(1 TO 8) AS P3DType
            DIM TCUBE(1 TO 8) AS P3DType
            DIM PLOT(1 TO 8) AS P2DType
            DIM PROJPARAMS AS PROJType

            CUBE(1).X =  100 : CUBE(1).Y = -100 : CUBE(1).Z =  100
            CUBE(2).X =  100 : CUBE(2).Y = -100 : CUBE(2).Z = -100
            CUBE(3).X =  100 : CUBE(3).Y =  100 : CUBE(3).Z = -100
            CUBE(4).X =  100 : CUBE(4).Y =  100 : CUBE(4).Z =  100
            CUBE(5).X = -100 : CUBE(5).Y = -100 : CUBE(5).Z =  100
            CUBE(6).X = -100 : CUBE(6).Y = -100 : CUBE(6).Z = -100
            CUBE(7).X = -100 : CUBE(7).Y =  100 : CUBE(7).Z = -100
            CUBE(8).X = -100 : CUBE(8).Y =  100 : CUBE(8).Z =  100


                                                                         32





            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            PROJPARAMS.EYEX = -1040
            PROJPARAMS.EYEY = -600
            PROJPARAMS.EYEZ = -1200
            PROJPARAMS.SCRD = 1700
            PROJPARAMS.THETA = 30
            PROJPARAMS.PHI = 45
            FOR I = 0 TO 100 STEP 2
            D3TRANSLATE 8, I, I, I, CUBE(1).X, TCUBE(1).X
            DUMMY = D3PROJECT(8,PROJPARAMS.EYEX,TCUBE(1).X,PLOT(1).X)
            GOSUB DRWCUBE
            SDELAY 2
            GOSUB DRWCUBE
            NEXT I
            FOR I = 98 TO 0 STEP -2
            D3TRANSLATE 8, I, I, I, CUBE(1).X, TCUBE(1).X
            DUMMY = D3PROJECT(8,PROJPARAMS.EYEX,TCUBE(1).X,PLOT(1).X)
            GOSUB DRWCUBE
            SDELAY 2
            GOSUB DRWCUBE
            NEXT I
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END

            DRWCUBE:
            FOR J=1 TO 3
            DRWLINE 2, 10, PLOT(J).X, PLOT(J).Y, PLOT(J+1).X, PLOT(J+1).Y
            NEXT J
            DRWLINE 2, 10, PLOT(4).X, PLOT(4).Y, PLOT(1).X, PLOT(1).Y
            FOR J=5 TO 7
            DRWLINE 2, 10, PLOT(J).X, PLOT(J).Y, PLOT(J+1).X, PLOT(J+1).Y
            NEXT J
            DRWLINE 2, 10, PLOT(8).X, PLOT(8).Y, PLOT(5).X, PLOT(5).Y
            FOR J=1 TO 4
            DRWLINE 2, 10, PLOT(J).X, PLOT(J).Y, PLOT(J+4).X, PLOT(J+4).Y
            NEXT J
            RETURN















                                                                         33





          DRWALINE

            PROTOTYPE

            SUB DRWALINE (ColrBits%, Colr%, X1%, Y1%, X2%, Y2%)

            INPUT

            ColrBits - number of bits of color
            Colr - index to color in current palette
            X1, Y1 - location of one endpoint of line
            X2, Y2 - location of other endpoint of line

            OUTPUT

            no value returned

            USAGE

            DRWALINE draws an antialiased line of the specified color
            using with endpoints located at (X1, Y1) and (X2,Y2).
            Antialiased lines trick the eye into seeing true vector lines
            instead of a jagged series of individual pixels.  This is
            accomplished by drawing two pixels of the same color but with
            different intensities (brightness) for each pixel drawn by
            DRWALINE.  The eye averages the pixels to see only a straight
            line.  Note that the palette must be set up with the correct
            color entries for the line to look correct.  All values of X1,
            Y1, X2 and Y2 are valid.  Any portion of the line that lies
            outside of the currently defined viewport will not be drawn.
            Colrbits should be a number in the range of 0 to 6 specifying
            the number of shades of color in the palette (20 =1 is one
            color shade; 26=64 is 64 shades of color).  These shades
            should be contiguous in the palette from index colr to index
            (colr + 2colrbits - 1) starting with the full desired
            brightness.  The best compromise of detail versus palette
            entries is about 3 (23=8 is 8 shades, or palette entries, of
            color).

            SEE ALSO

            DRWLINE, DRWBOX, SETVIEW

            EXAMPLE

            REM THIS SHOWS NORMAL AND ANTIALISED LINES TOGETHER
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z
            DIM Pal AS STRING * 768

            CLS
            IF WHICHVGA = 0 THEN STOP
            DUMMY = RES640
            REM SET UP THE PALETTE


                                                                         34





            INTSBITS = 2
            NUMLEVELS = 2 ^ INTSBITS
            PALGET Pal, 0, 255
            FOR I = 0 TO NUMLEVELS - 1
               OFST = 1 + (16 + I) * 3
               MID$(Pal, OFST + 0, 1) = CHR$(63 - 35 * I / (NUMLEVELS - 1))
               MID$(Pal, OFST + 1, 1) = CHR$(63 - 35 * I / (NUMLEVELS - 1))
               MID$(Pal, OFST + 2, 1) = CHR$(63 - 35 * I / (NUMLEVELS - 1))
            NEXT I
            PALSET Pal, 0, 255
            OFST = GETMAXY / 2 - 1
            YA = GETMAXY / 3
            YB = 2 * GETMAXY / 3
            FOR Y = 0 TO OFST STEP 12
               DRWLINE 1, 15, 0, YA, GETMAXX, Y
               DRWALINE INTSBITS, 16, 0, YB, GETMAXX, OFST + Y
            NEXT Y
            WHILE INKEY$ = ""
            WEND
            DUMMY = RESTEXT
            END



































                                                                         35





          DRWBOX

            PROTOTYPE

            SUB DRWBOX (Mode%, Color%, X1%, Y1%, X2%, Y2%)

            INPUT

            Mode - pixel write mode (SET=1, XOR=2, OR=3, AND=4)
            Color - index to color in current palette
            X1, Y1 - location of top left corner
            X2, Y2 - location of bottom right corner

            OUTPUT

            no value returned

            USAGE

            DRWBOX draws a rectangle of the color specified using Mode
            with opposite vertices defined by (X1, Y1) and (X2, Y2).  The
            vertices given do not need to be exactly the top left and
            bottom right.  They only have to reference opposite sides of
            the rectangle.  Any portion of the rectangle that lies outside
            of the currently defined viewport will not be drawn.

            SEE ALSO

            DRWFILLBOX, DRWLINE, SETVIEW

            EXAMPLE

            REM DRAWS A BOX AROUND THE WHOLE SCREEN
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE=VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            DRWBOX 1, 10, 0, 0, 639, 479
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END












                                                                         36





          DRWCIRARC

            PROTOTYPE

            SUB DRWCIRARC (Mode%, Color%, Xcenter%, Ycenter%, Radius%,
            StartAng&, EndAng&)

            INPUT

            Mode - pixel write mode (SET=1, XOR=2, OR=3, AND=4)
            Color - index to color in current palette
            Xcenter, Ycenter - location of center of circle
            Radius - distance from center to edge of circle
            StartAng, EndAng - start and end angles in degrees

            OUTPUT

            no value returned

            USAGE

            DRWCIRARC draws a circular  arc of the specified color and
            mode with the center located at (Xcenter, Ycenter), radius of
            Radius, starting at the angle specified by StartAng and ending
            at the angle specified by EndAng.  All values of Xcenter,
            Ycenter, Radius, StartAng, and EndAng are valid.  However,
            StartAng must be less than EndAng.  Any portion of the arc
            that lies outside of the currently defined viewport will not
            be drawn.

            SEE ALSO

            DRWCIRCLE, DRWELLARC

            EXAMPLE

            REM DRAWS SOME CIRCULAR ARCS
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            IF WHICHVGA = 0 THEN END
            DUMMY = RES640
            FOR I = 1 TO 60
               R = I * 5
               SANG = I * 6
               DRWCIRARC 1, 10, GETMAXX \ 2, GETMAXY \ 2, R, SANG, 360
            NEXT I
            WHILE INKEY$ = ""
            WEND
            DUMMY = RESTEXT
            CLS
            END




                                                                         37





          DRWCIRCLE

            PROTOTYPE

            SUB DRWCIRCLE (Mode%, Color%, Xcenter%, Ycenter%, Radius%)

            INPUT

            Mode - pixel write mode (SET=1, XOR=2, OR=3, AND=4)
            Color - index to color in current palette
            Xcenter, Ycenter - location of center of circle
            Radius - distance from center to edge of circle

            OUTPUT

            no value returned

            USAGE

            DRWCIRCLE draws a circle of the specified color using Mode
            with the center located at (Xcenter, Ycenter) and a radius of
            Radius.  All values of Xcenter, Ycenter and Radius are valid.
            Any portion of the circle that lies outside of the currently
            defined viewport will not be drawn.

            SEE ALSO

            DRWCIRARC, DRWELLIPSE, DRWFILLCIRCLE, SETVIEW

            EXAMPLE

            REM DRAWS A CIRCLE AT THE CENTER OF THE SCREEN
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE=VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            DRWCIRCLE 1, 10, 320, 240, 200
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END













                                                                         38





          DRWCUBICBEZIER

            PROTOTYPE

            SUB DRWCUBICBEZIER (Mode%, Color%, Pon1%, Poff1%, Poff2%,
            Pon2%)

            INPUT

            Mode - pixel write mode (SET=1, XOR=2, OR=3, AND=4)
            Color - index to color in current palette
            Pon1% - P2DType variable containing the start point
            Poff1% - P2DType variable containing the first offset point
            Poff2% - P2DType variable containing the second offset point
            Pon2% - P2DType variable containing the end  point

            OUTPUT

            no value returned

            USAGE

            DRWCUBICBEZIER draws a standard cubic Bezier curve connecting
            the points Pon1 and Pon2 using the specified Mode and Color.
            The off-curve control points are Poff1 and Poff2.  A technical
            description of cubic Bezier curves is beyond the scope of this
            manual.  However, most advanced computer graphics texts
            contain discussions on this topic.

            SEE ALSO

            DRWCIRARC, DRWELLARC

            EXAMPLE

            REM SHOW DRWCUBICBEZIER
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            DIM P(3) AS P2DType

            IF WHICHCPU < 386 THEN END
            IF WHICHVGA = 0 THEN END
            IF RES640 <> 1 THEN
               DUMMY = RESTEXT
               END
            END IF

            P(0).X = 260
            P(0).Y = 240

            P(1).X = 310
            P(1).Y = 360



                                                                         39





            P(2).X = 330
            P(2).Y = 120

            P(3).X = 380
            P(3).Y = 240

            DRWCIRCLE 1, 12, P(0).X, P(0).Y, 2
            DRWCIRCLE 1, 12, P(1).X, P(1).Y, 2
            DRWCIRCLE 1, 12, P(2).X, P(2).Y, 2
            DRWCIRCLE 1, 12, P(3).X, P(3).Y, 2

            DRWCUBICBEZIER 1, 15, P(0).X, P(1).X, P(2).X, P(3).X

            WHILE INKEY$ = ""
            WEND
            DUMMY = RESTEXT
            CLS
            END






































                                                                         40





          DRWELLARC

            PROTOTYPE

            SUB DRWELLARC (Mode%, Color%, Xcenter%, Ycenter%, RadiusX%,
            RadiusX%, StartAng&, EndAng&)

            INPUT

            Mode - pixel write mode (SET=1, XOR=2, OR=3, AND=4)
            Color - index to color in current palette
            Xcenter, Ycenter - location of center of ellipse
            RadiusX - radius parallel to X axis
            RadiusY - radius parallel to Y axis
            StartAng, EndAng - start and end angles in degrees

            OUTPUT

            no value returned

            USAGE

            DRWELLARC draws an elliptical arc of the specified color and
            mode with the center located at (Xcenter, Ycenter).  The
            radius in the horizontal direction is RaduisX and the radius
            in the vertical direction is RadiusY.  The starting angle is
            specified by StartAng and ends at the angle specified by
            EndAng.  All values of Xcenter, Ycenter, RadiusX, RadiusY,
            StartAng and EndAng are valid.  However, StartAng must be less
            than EndAng.  Any portion of the arc that lies outside of the
            currently defined viewport will not be drawn.

            SEE ALSO

            DRWCIRARC, DRWELLIPSE

            EXAMPLE

            REM DRAWS SOME ELLIPTICAL ARCS
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            IF WHICHVGA = 0 THEN END
            DUMMY = RES640
            FOR I = 1 TO 60
               RX = I * 5
               RY = I * 3
               SANG = I * 6
               DRWELLARC 1, 10, GETMAXX \ 2, GETMAXY \ 2, RX, RY, SANG, 360
            NEXT I
            WHILE INKEY$ = ""
            WEND
            DUMMY = RESTEXT
            CLS


                                                                         41





            END























































                                                                         42





            DRWELLIPSE

            PROTOTYPE

            SUB DRWELLIPSE (Mode%, Color%, Xcenter%, Ycenter%, RadiusX%,
            RadiusY%)

            INPUT

            Mode - pixel write mode (SET=1, XOR=2, OR=3, AND=4)
            Color - index to color in current palette
            Xcenter, Ycenter - location of center of ellipse
            RadiusX - radius parallel to X axis
            RadiusY - radius parallel to Y axis

            OUTPUT

            no value returned

            USAGE

            DRWELLIPSE draws an ellipse of the specified color using Mode
            with the center defined by (Xcenter, Ycenter).  The radius in
            the horizontal direction is RaduisX and the radius in the
            vertical direction is RadiusY.  All values of Xcenter,
            Ycenter, RadiusX and RadiusY are valid.  Any portion of the
            ellipse that lies outside of the currently defined viewport
            will not be drawn.

            SEE ALSO

            DRWCIRCLE, DRWELLARC, DRWFILLELLIPSE, SETVIEW

            EXAMPLE

            REM DRAWS AN ELLIPSE AT THE CENTER OF THE SCREEN
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE=VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            DRWELLIPSE 1, 10, 320, 240, 318, 238
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END









                                                                         43





          DRWFILLBOX

            PROTOTYPE

            SUB DRWFILLBOX (Mode%, Color%, X1%, Y1%, X2%, Y2%)

            INPUT

            Mode - pixel write mode (SET=1, XOR=2, OR=3, AND=4)
            Color - index to color in current palette
            X1, Y1 - location of top left corner
            X2, Y2 - location of bottom right corner

            OUTPUT

            no value returned

            USAGE

            DRWFILLBOX draws a filled rectangle of the color specified
            using Mode with opposite vertices defined by (X1, Y1) and (X2,
            Y2).  The vertices given do not need to be exactly the top
            left and bottom right.  They only have to reference opposite
            sides of the rectangle.  Any portion of the rectangle that
            lies outside of the currently defined viewport will not be
            drawn.

            SEE ALSO

            DRWBOX, DRWLINE, FILLCONVEXPOLY, FILLPOLY, SETVIEW

            EXAMPLE

            REM DRAWS A FILLED BOX
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY = RES640
            DRWFILLBOX 1, 10, 100, 100, 200, 200
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END











                                                                         44





          DRWFILLCIRCLE

            PROTOTYPE

            SUB DRWFILLCIRCLE (Mode%, Color%, Xcenter%, Ycenter%, Radius%)

            INPUT

            Mode - pixel write mode (SET=1, XOR=2, OR=3, AND=4)
            Color - index to color in current palette
            Xcenter, Ycenter - location of center of circle
            Radius - distance from center to edge of circle

            OUTPUT

            no value returned

            USAGE

            DRWFILLCIRCLE draws a filled circle of the specified color
            using Mode with the center located at (Xcenter, Ycenter) and a
            radius of Radius.  All values of Xcenter, Ycenter and Radius
            are valid.  Any portion of the circle that lies outside of the
            currently defined viewport will not be drawn.

            SEE ALSO

            DRWCIRCLE, SETVIEW

            EXAMPLE

            REM DRAWS A FILLED CIRCLE
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY = RES640
            DRWFILLCIRCLE 1, 10, 320, 240, 50
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END













                                                                         45





          DRWFILLELLIPSE

            PROTOTYPE

            SUB DRWFILLELLIPSE (Mode%, Color%, Xcenter%, Ycenter%,
            RadiusX%, RadiusY%)

            INPUT

            Mode - pixel write mode (SET=1, XOR=2, OR=3, AND=4)
            Color - index to color in current palette
            Xcenter, Ycenter - location of center of ellipse
            RadiusX - radius parallel to X axis
            RadiusY - radius parallel to Y axis

            OUTPUT

            no value returned

            USAGE

            DRWFILLELLIPSE draws a filled ellipse of the specified color
            using Mode with the center defined by (Xcenter, Ycenter).  The
            radius in the horizontal direction is RaduisX and the radius
            in the vertical direction is RadiusY.  All values of Xcenter,
            Ycenter, RadiusX and RadiusY are valid.  Any portion of the
            ellipse that lies outside of the currently defined viewport
            will not be drawn.

            SEE ALSO

            DRWELLIPSE, SETVIEW

            EXAMPLE

            REM DRAWS A FILLED ELLIPSE
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY = RES640
            DRWFILLELLIPSE 1, 10, 320, 240, 118, 50
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END









                                                                         46





          DRWLINE

            PROTOTYPE

            SUB DRWLINE (Mode%, Color%, X1%, Y1%, X2%, Y2%)

            INPUT

            Mode - pixel write mode (SET=1, XOR=2, OR=3, AND=4)
            Color - index to color in current palette
            X1, Y1 - location of one endpoint of line
            X2, Y2 - location of other endpoint of line

            OUTPUT

            no value returned

            USAGE

            DRWLINE draws a line of the specified color using Mode with
            endpoints located at (X1, Y1) and (X2, Y2).  All values of X1,
            Y1, X2 and Y2 are valid.  Any portion of the line that lies
            outside of the currently defined viewport will not be drawn.

            SEE ALSO

            DRWALINE, DRWBOX, SETVIEW

            EXAMPLE

            REM DRAWS A LINE FROM 0,0 TO THE CENTER OF THE SCREEN
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE=VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            DRWLINE 1, 10, 0, 0, 320, 240
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END














                                                                         47





          DRWPOINT

            PROTOTYPE

            SUB DRWPOINT (Mode%, Color%, X%, Y%)

            INPUT

            Mode - pixel write mode (SET=1, XOR=2, OR=3, AND=4)
            Color - index to color in current palette
            X, Y - location of pixel to write

            OUTPUT

            no value returned

            USAGE

            DRWPOINT draws a single point of the specified color using
            Mode at (X, Y).  All values of X and Y are valid.  If the
            point (X, Y) lies outside of the currently defined viewport,
            no drawing will take place.

            SEE ALSO

            GETPOINT, SETVIEW

            EXAMPLE

            REM DRAWS A POINT AT THE CENTER OF THE SCREEN
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE=VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            DRWPOINT 1, 10, 320, 240
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END















                                                                         48





          DRWSTRING

            PROTOTYPE

            SUB DRWSTRING (Mode%, FColor%, BColor%, Strng$, X%, Y%)

            INPUT

            Mode - pixel write mode (no action=0, SET=1, XOR=2, OR=3,
            AND=4)
            FColor - foreground index to color in current palette
            BColor - background index to color in current palette
            Strng$ - string of ASCII characters to be drawn
            X, Y - location of upper, left corner of block

            OUTPUT

            no value returned

            USAGE

            DRWSTRING takes the ASCII characters contained in Strng$ and
            creates a graphics block similar to the blocks used by Blkget
            and Blkput and places this block on the screen at the
            specified coordinates.  The characters are drawn with color
            FColor using the current font and the background is color
            BColor.  When mode 0, no action, is used, the graphics block
            is created in memory retrievable by GETLASTSTRING, but no text
            is actually drawn on the screen.  (Note: the system font is
            automatically installed when WHICHVGA is called.)

            SEE ALSO

            FONTSET, FONTGETINFO, FONTSYSTEM, DRWSTRINGDN, DRWSTRINGLT,
            DRWSTRINGRT, GETLASTSTRING

            EXAMPLE

            REM DRAWS SOME NORMAL TEXT AT THE CENTER OF THE SCREEN
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE=VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            A$ = "HELLO WORLD"
            DRWSTRING 1, 10, 0, A$, 320, 240
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END





                                                                         49





          DRWSTRINGDN

            PROTOTYPE

            SUB DRWSTRINGDN (Mode%, FColor%, BColor%, Strng$, X%, Y%)

            INPUT

            Mode - pixel write mode (no action=0, SET=1, XOR=2, OR=3,
            AND=4)
            FColor - foreground index to color in current palette
            BColor - background index to color in current palette
            Strng$ - string of ASCII characters to be drawn
            X, Y - location of lower, right corner of block

            OUTPUT

            no value returned

            USAGE

            DRWSTRINGDN takes the ASCII characters contained in Strng$ and
            creates a graphics block similar to the blocks used by Blkget
            and Blkput.  The characters are drawn with color FColor using
            the current font and the background is color BColor.  When
            mode 0, no action, is used, the graphics block is created in
            memory retrievable by GETLASTSTRING, but no text is actually
            drawn on the screen.  (Note: the system font is automatically
            installed when WHICHVGA is called.)  The text is drawn upside
            down with X, Y specifying the lower, right corner.  This
            corner corresponds to the upper, left corner when the text is
            oriented upright.

            SEE ALSO

            FONTSET, FONTGETINFO, FONTSYSTEM, DRWSTRING, DRWSTRINGLT,
            DRWSTRINGRT, GETLASTSTRING

            EXAMPLE

            REM DRAWS SOME UP-SIDE-DOWN TEXT AT THE CENTER OF THE SCREEN
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE=VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            A$ = "HELLO WORLD"
            DRWSTRINGDN 1, 10, 0, A$, 320, 240
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END



                                                                         50





          DRWSTRINGLT

            PROTOTYPE

            SUB DRWSTRINGLT (Mode%, FColor%, BColor%, Strng$, X%, Y%)

            INPUT

            Mode - pixel write mode (no action=0, SET=1, XOR=2, OR=3,
            AND=4)
            FColor - foreground index to color in current palette
            BColor - background index to color in current palette
            Strng$ - string of ASCII characters to be drawn
            X, Y - location of lower, left corner of block

            OUTPUT

            no value returned

            USAGE

            DRWSTRINGLT takes the ASCII characters contained in Strng$ and
            creates a graphics block similar to the blocks used by Blkget
            and Blkput.  The characters are drawn with color FColor using
            the current font and the background is color BColor.  When
            mode 0, no action, is used, the graphics block is created in
            memory retrievable by GETLASTSTRING, but no text is actually
            drawn on the screen.  (Note: the system font is automatically
            installed when WHICHVGA is called.)  The text block is rotated
            90 to the left with X, Y specifying the lower, left corner.
            This corner corresponds to the upper, left corner when the
            text is oriented upright.


            SEE ALSO

            FONTSET, FONTGETINFO, FONTSYSTEM, DRWSTRING, DRWSTRINGDN,
            DRWSTRINGRT, GETLASTSTRING

            EXAMPLE

            REM DRAWS SOME TEXT ROTATED BY 90 DEGREES TO THE LEFT AT THE
            REM CENTER OF THE SCREEN
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE=VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            A$ = "HELLO WORLD"
            DRWSTRINGLT 1, 10, 0, A$, 320, 240
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE


                                                                         51





            END























































                                                                         52





          DRWSTRINGRT

            PROTOTYPE

            SUB DRWSTRINGRT (Mode%, FColor%, BColor%, Strng$, X%, Y%)

            INPUT

            Mode - pixel write mode (no action=0, SET=1, XOR=2, OR=3,
            AND=4)
            FColor - foreground index to color in current palette
            BColor - background index to color in current palette
            Strng$ - string of ASCII characters to be drawn
            X, Y - location of upper, right corner of block

            OUTPUT

            no value returned

            USAGE

            DRWSTRINGRT takes the ASCII characters contained in Strng$ and
            creates a graphics block similar to the blocks used by Blkget
            and Blkput.  The characters are drawn with color FColor using
            the current font and the background is color BColor.  When
            mode 0, no action, is used, the graphics block is created in
            memory retrievable by GETLASTSTRING, but no text is actually
            drawn on the screen.  (Note: the system font is automatically
            installed when WHICHVGA is called.)  The text block is rotated
            90 to the right with X, Y specifying the upper, right corner.
            This corner corresponds to the upper, left corner if the text
            is oriented upright.


            SEE ALSO

            FONTSET, FONTGETINFO, FONTSYSTEM, DRWSTRING, DRWSTRINGDN,
            DRWSTRINGLT, GETLASTSTRING

            EXAMPLE

            REM DRAWS SOME TEXT ROTATED BY 90 DEGREES TO THE RIGHT AT THE
            REM CENTER OF THE SCREEN
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE=VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            A$ = "HELLO WORLD"
            DRWSTRINGRT 1, 10, 0, A$, 320, 240
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE


                                                                         53





            END























































                                                                         54





          FILLAREA

            PROTOTYPE

            SUB FILLAREA (XSeed%, YSeed%, BorderColor%, FillColor%)

            INPUT

            XSeed, YSeed - seed location to start fill
            BorderColor - index to color in current palette at which
            filling stops
            FillColor - index to color in current palette to fill within
            the border

            OUTPUT

            no value returned

            USAGE

            FILLAREA fills a region with a new color specified by
            FillColor.  The region is defined by any line or curve of the
            color BorderColor or by the edge of the viewport.  All
            graphics within the region are lost and covered with the
            FillColor.  The border is not effected.

            SEE ALSO

            DRWFILLBOX, DRWFILLCIRCLE, DRWFILLELLIPSE, FILLCOLOR,
            FILLCONVEXPOLY, FILLPAGE, FILLPOLY, FILLSCREEN, FILLVIEW,
            SETVIEW

            EXAMPLE

            REM FILLS A BOX WITH A COLOR
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE=VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            DRWBOX 1, 10, 0, 0, 100, 100
            FILLAREA 1, 1, 10, 7
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END









                                                                         55





          FILLCOLOR

            PROTOTYPE

            SUB FILLCOLOR (XSeed%, YSeed%, OldColor%, NewColor%)

            INPUT

            XSeed, YSeed - seed location to start fill
            OldColor - index to color in current palette to change
            NewColor - index to color in current palette to replace
            OldColor

            OUTPUT

            no value returned

            USAGE

            FILLCOLOR replaces every existence of OldColor with NewColor
            within a region.  The region is defined as any pixel of
            OldColor which has a path of pixels of OldColor or NewColor
            with sides touching back to the seed point, (XSeed, YSeed).
            Therefore, only pixels of OldColor are modified and no other
            information is changed.

            SEE ALSO

            DRWFILLBOX, DRWFILLCIRCLE, DRWFILLELLIPSE, FILLAREA,
            FILLCONVEXPOLY, FILLPAGE, FILLPOLY, FILLSCREEN, FILLVIEW,
            SETVIEW

            EXAMPLE

            REM REPLACES THE BLACK COLOR WITH A NEW COLOR
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE=VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            DRWBOX 1, 10, 0, 0, 100, 100
            DRWBOX 1, 12, 20, 20, 80, 80
            FILLCOLOR 1, 1, 0, 7
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END








                                                                         56





          FILLCONVEXPOLY

            PROTOTYPE

            SUB FILLCONVEXPOLY (PolyColor%, NumPoints%, PointArray%)

            INPUT

            PolyColor - index to color in current palette
            NumPoints - number of points in PointArray
            PointArray - P2DType array holding points of polygon

            OUTPUT

            no value returned

            USAGE

            FILLCONVEXPOLY draws a solid polygon outlined by the points
            given in PointArray.  The points are expected to be
            consecutive and the resulting polygon should be convex (ie.
            the polygon should not curve in on itself like a kidney bean).
            The function also assumes that the last point in the array
            connects to the first.

            SEE ALSO

            D3PROJECT, DRWFILLBOX, FILLAREA, FILLCOLOR, FILLPAGE,
            FILLPOLY, FILLSCREEN, FILLVIEW

            EXAMPLE

            REM SHOW FILLCONVEXPOLY
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z
            DIM T(0 TO 20) AS P2DType

            VGA = WHICHVGA
            DUMMY = RES640

            FOR I = 0 TO 99
               T(0).X = RND * GETMAXX
               T(0).Y = RND * GETMAXY
               T(1).X = RND * GETMAXX
               T(1).Y = RND * GETMAXY
               T(2).X = RND * GETMAXX
               T(2).Y = RND * GETMAXY
               C = RND * 15
               FILLCONVEXPOLY C, 3, T(0).X
            NEXT I

            WHILE INKEY$ = ""
            WEND



                                                                         57





            DUMMY = RESTEXT
            END






















































                                                                         58





          FILLPAGE

            PROTOTYPE

            SUB FILLPAGE (Color%)

            INPUT

            Color - index to color in current palette

            OUTPUT

            no value returned

            USAGE

            FILLPAGE clears the currently active page with the specified
            color.  All information on the page is lost.  (Note, a faster
            method to clear the page is to call any of the 'RES###'
            functions.  These reset the graphics screen and automatically
            clear it to color index zero as well as reset the default
            palette.)

            SEE ALSO

            DRWFILLBOX, DRWFILLCIRCLE, DRWFILLELLIPSE, FILLAREA,
            FILLCOLOR, FILLCONVEXPOLY, FILLPOLY, FILLSCREEN, FILLVIEW

            EXAMPLE

            REM FILLS THE CURRENT VIDEO PAGE WITH A COLOR
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE=VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            DUMMY=PAGEACTIVE(0)
            FILLPAGE 10
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END













                                                                         59





          FILLPOLY

            PROTOTYPE

            SUB FILLPOLY (PolyColor%, NumPoints%, PointArray%)

            INPUT

            PolyColor - index to color in current palette
            NumPoints - number of points in PointArray
            PointArray - P2DType array holding points of polygon

            OUTPUT

            no value returned

            USAGE

            FILLPOLY draws a solid polygon outlined by the points given in
            PointArray.  The points are expected to be consecutive.
            However, there are no restrictions on the relative locations
            of the points.  The polygon may curve in on itself or have
            crossed lines.  The function also assumes that the last point
            in the array connects to the first.  FILLPOLY can be used
            interchangeably with FILLCONVEXPOLY, although FILLPOLY is
            slightly slower.

            Special thanks to Eric Jorgensen for providing the algorithm
            which formed the basis for FILLPOLY.

            SEE ALSO

            D3PROJECT, DRWFILLBOX, FILLAREA, FILLCOLOR, FILLCONVEXPOLY,
            FILLPAGE, FILLSCREEN, FILLVIEW

            EXAMPLE

            REM SHOW FILLPOLY
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            DIM P(4) AS P2DType

            IF WHICHCPU < 386 THEN END
            IF WHICHVGA = 0 THEN END
            IF RES640 <> 1 THEN
               DUMMY = RESTEXT
               END
            END IF

            P(0).X = 320
            P(0).Y = 40

            P(1).X = 203


                                                                         60





            P(1).Y = 401

            P(2).X = 510
            P(2).Y = 179

            P(3).X = 130
            P(3).Y = 179

            P(4).X = 437
            P(4).Y = 401

            FILLPOLY 10, 5, P(0).X

            WHILE INKEY$ = ""
            WEND
            DUMMY = RESTEXT
            CLS
            END






































                                                                         61





          FILLSCREEN

            PROTOTYPE

            SUB FILLSCREEN (Color%)

            INPUT

            Color - index to color in current palette

            OUTPUT

            no value returned

            USAGE

            FILLSCREEN clears the entire screen with the specified color.
            All information on the screen is lost.  (Note, a faster method
            to clear the screen is to call any of the 'RES###' functions.
            These reset the graphics screen and automatically clear it to
            color index zero as well as reset the default palette.)

            SEE ALSO

            DRWFILLBOX, DRWFILLCIRCLE, DRWFILLELLIPSE, FILLAREA,
            FILLCOLOR, FILLCONVEXPOLY, FILLPAGE, FILLPOLY, FILLVIEW

            EXAMPLE

            REM FILLS THE SCREEN WITH A COLOR
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE=VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            FILLSCREEN 10
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END















                                                                         62





          FILLVIEW

            PROTOTYPE

            SUB FILLVIEW (Color%)

            INPUT

            Color - index to color in current palette

            OUTPUT

            no value returned

            USAGE

            FILLVIEW fills the currently defined viewport with the
            specified color.  All information in the viewport is lost.

            SEE ALSO

            DRWFILLBOX, DRWFILLCIRCLE, DRWFILLELLIPSE, FILLAREA,
            FILLCOLOR, FILLCONVEXPOLY, FILLPAGE, FILLPOLY, FILLSCREEN,
            SETVIEW

            EXAMPLE

            REM FILLS THE VIEWPORT WITH A COLOR
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE=VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            SETVIEW 100, 100, 539, 379
            FILLVIEW 10
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END
















                                                                         63





          FONTGETINFO

            PROTOTYPE

            SUB FONTGETINFO (Width%, Height%)

            INPUT

            no input parameters

            OUTPUT

            no value returned
            Width - width in pixels of current font
            Height - height in pixels of current font

            USAGE

            FONTGETINFO returns in Width and Height the dimensions of the
            currently loaded font.

            SEE ALSO

            FONTSET, FONTSYSTEM

            EXAMPLE

            REM GET INFO ON THE SYSTEM FONT
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE=VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            FONTGETINFO WDTH, HGTH
            A$ = "SYSTEM FONT WIDTH =" + STR$(WDTH)
            B$ = "SYSTEM FONT HEIGHT =" + STR$(HGTH)
            DRWSTRING 1, 7, 0, A$, 0, 0
            DRWSTRING 1, 7, 0, B$, 0, 20
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END













                                                                         64





          FONTSET

            PROTOTYPE

            SUB FONTSET (Font$)

            INPUT

            Font$ - string * 4098 containing font data

            OUTPUT

            no value returned

            USAGE

            FONTSET loads the current font with the data in Font$.  The
            string must have at least 4098 members.  The first byte of
            Font$ holds the font width (1 to 8) and the second byte holds
            the font height (1 to 16).  The remaining 4096 bytes are the
            character raster data, 16 bytes per character.

            SEE ALSO

            FONTGETINFO, FONTSYSTEM

            EXAMPLE

            See FONTSYSTEM



























                                                                         65





          FONTSYSTEM

            PROTOTYPE

            SUB FONTSYSTEM ()

            INPUT

            no input parameters

            OUTPUT

            no value returned

            USAGE

            FONTSYSTEM sets the current font to the standard system font.
            This font is automatically set when WHICHVGA is called.

            SEE ALSO

            WHICHVGA, FONTGETINFO, FONTSET

            EXAMPLE

            REM LOAD A FONT FROM DISK AND ENABLE IT
            REM THEN GO BACK TO THE SYSTEM FONT
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            DIM NEWFONT AS STRING * 4098

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            OPEN "DRAGON.FNT" FOR BINARY AS #1
            GET #1, , NEWFONT
            CLOSE #1
            FONTSET NEWFONT
            DRWSTRING 1, 7, 0, "The Dragon Font!", 0, 0
            FONTSYSTEM
            DRWSTRING 1, 7, 0, "The System Font!", 0, 20
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END










                                                                         66





          GETARCCOS

            PROTOTYPE

            FUNCTION GETARCCOS% (Value&)

            INPUT

            Value - number between -1 and +1 scaled up by 13 bits (8192)

            OUTPUT

            GETARCCOS returns the arc cosine of Value in degrees.

            USAGE

            GETARCCOS returns the arc cosine in degrees for the given
            value.  The return will be between 0 and 180 degrees.  Value
            should be between -8192 and +8192 representing the range -1 to
            +1.  Input values outside this range are invalid and GETARCCOS
            will return -32768. Floating point values are ignored.  This
            function uses an integer lookup table stored within the
            library in order to produce the fastest possible results.  No
            floating point arithmetic is used.  The scale factor of 13
            bits (8192) was chosen because this is the number of bits at
            which every change of one degree gives a change in the value
            of the sine (or cosine) function.

            SEE ALSO

            GETARCSIN, GETARCTAN, GETCOS, GETSIN, GETTAN

            EXAMPLE

            REM SHOW GETARCCOS
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            DRWBOX 1, 10, 0, 0, 639, 479
            DRWLINE 1, 10, 0, 240, 639, 240
            DRWLINE 1, 10, 320, 0, 320, 479
            DEG2RAD! = 4 * ATN(1) / 180
            FOR I = -8192 TO 8192 STEP 16
               Y1& = GETARCCOS(I)
               DRWPOINT 1, 12, 320 + Y1& * 3, 240 - I / 34
            NEXT I
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END



                                                                         67





          GETARCSIN

            PROTOTYPE

            FUNCTION GETARCSIN (Value&)

            INPUT

            Value - number between -1 and +1 scaled up by 13 bits (8192)

            OUTPUT

            GETARCSIN returns the arc sine of Value in degrees.

            USAGE

            GETARCSIN returns the arc sine in degrees for the given value.
            The return will be between -90 and +90 degrees.  Value should
            be between -8192 and +8192 representing the range -1 to +1.
            Input values outside this range are invalid and GETARCSIN will
            return -32768. Floating point values are ignored.  This
            function uses an integer lookup table stored within the
            library in order to produce the fastest possible results.  No
            floating point arithmetic is used.  The scale factor of 13
            bits (8192) was chosen because this is the number of bits at
            which every change of one degree gives a change in the value
            of the sine (or cosine) function.

            SEE ALSO

            GETARCCOS, GETARCTAN, GETCOS, GETSIN, GETTAN

            EXAMPLE

            REM SHOW GETARCSIN
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            DRWBOX 1, 10, 0, 0, 639, 479
            DRWLINE 1, 10, 0, 240, 639, 240
            DRWLINE 1, 10, 320, 0, 320, 479
            DEG2RAD! = 4 * ATN(1) / 180
            FOR I = -8192 TO 8192 STEP 16
               Y1& = GETARCSIN(I)
               DRWPOINT 1, 12, 320 + Y1& * 3, 240 - I / 34
            NEXT I
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END



                                                                         68





          GETARCTAN

            PROTOTYPE

            FUNCTION GETARCTAN (Value&)

            INPUT

            Value - long integer representing a decimal scaled up by 13
            bits (8192)

            OUTPUT

            GETARCTAN returns the arc tangent of Value in degrees.

            USAGE

            GETARCTAN returns the arc cosine in degrees for the given
            value.  The return will be between -89 and +89 degrees.  Value
            can be any long integer.  It is interpreted as a decimal
            scaled up by 8192 (13 bits). Floating point values are
            ignored.  This function uses an integer lookup table stored
            within the library in order to produce the fastest possible
            results.  No floating point arithmetic is used.  The scale
            factor of 13 bits (8192) was chosen because this is the number
            of bits at which every change of one degree gives a change in
            the value of the sine (or cosine) function.

            SEE ALSO

            GETARCCOS, GETARCSIN, GETCOS, GETSIN, GETTAN

            EXAMPLE

            REM SHOW GETARCTAN
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            DRWBOX 1, 10, 0, 0, 639, 479
            DRWLINE 1, 10, 0, 240, 639, 240
            DRWLINE 1, 10, 320, 0, 320, 479
            DEG2RAD! = 4 * ATN(1) / 180
            FOR I = -8192 TO 8192 STEP 16
               Y1& = GETARCTAN(I)
               Y2& = ATN(I / 8192) / DEG2RAD!
               DRWPOINT 1, 12, 320 + Y1& * 6, 240 - I / 34
               DRWPOINT 1, 15, 320 + Y2& * 6, 240 - I / 34
            NEXT I
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE


                                                                         69





            END























































                                                                         70





          GETCOS

            PROTOTYPE

            FUNCTION GETCOS& (Angle&)

            INPUT

            Angle - angle in degrees

            OUTPUT

            GETCOS returns the cosine of Angle scaled up by 13 bits
            (8192).

            USAGE

            GETCOS returns the cosine of the specified angle.  Angle can
            be any long value; floating point values are ignored.  The
            return value has been multiplied by 8192.  This function uses
            an integer lookup table stored within the library in order to
            produce the fastest possible results.  No floating point
            arithmetic is used.  The scale factor of 13 bits (8192) was
            chosen because this is the number of bits at which every
            change of one degree gives a change in the value of the sine
            (or cosine) function.

            SEE ALSO

            GETARCCOS, GETARCSIN, GETARCTAN, GETSIN, GETTAN

            EXAMPLE

            REM SHOW GETCOS
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            DRWBOX 1, 10, 0, 0, 639, 479
            DRWLINE 1, 10, 0, 240, 639, 240
            DRWLINE 1, 10, 320, 0, 320, 479
            DEG2RAD! = 4 * ATN(1) / 180
            FOR I = -360 TO 360
               Y1& = GETCOS(I)
               Y1& = Y1& * 240 / 8192
               Y2& = 240 * COS(I * DEG2RAD!)
               DRWPOINT 1, 15, 320 + I, 240 - Y1&
               DRWPOINT 1, 12, 320 + I, 240 - Y2&
            NEXT I
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE


                                                                         71





            END























































                                                                         72





          GETLASTSTRING

            PROTOTYPE

            SUB GETLASTSTRING (GfxBlk%)

            INPUT

            no input parameters

            OUTPUT

            no value returned
            GfxBlk - integer destination array holding bitmap of text
            block

            USAGE

            GETLASTSTRING returns the text drawn on the screen by the last
            called DRWSTRING function.  The text is returned in GfxBlk
            which may be used with BLKPUT or the sprite functions.  The
            text in GfxBlk is oriented in the same manner as the last
            called DRWSTRING function.  The intended use is to call the
            DRWSTRING function using mode 0 which does not actually draw
            text on the screen.  GETLASTSTRING should be called
            immediately after the DRWSTRING function to prevent possible
            loss of data caused by other functions.

            GfxBlk must be dimensioned as a short integer array with a
            size in integers equal to

                    [(fontwidth*stringlength)*(fontheight)] / 2+3.

            The font's dimensions can be obtained by calling FONTGETINFO
            and the string's length can be obtained using Basic's LEN
            function.  Note, however, that GfxBlk can be quite large.  If
            the size of GfxBlk is insufficient, GETLASTSTRING will
            overwrite any data in memory contained beyond GfxBlk and may
            possibly cause the system to crash.

            Arrays should be passed by giving the element within the array
            from where the action should take place.  This allows the
            programmer to store more than one item within the same array
            or act on only a portion of the array.

            SEE ALSO

            BLKPUT, DRWSTRING, DRWSTRINGDN, DRWSTRINGLT, DRWSTRINGRT,
            FONTGETINFO

            EXAMPLE

            REM USES GETLASTSTRING TO DRAW SOME TEXT AT THE CENTER OF THE
            SCREEN


                                                                         73





            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE=VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            A$ = "HELLO WORLD"
            DRWSTRING 0, 10, 0, A$, 0, 0
            FONTGETINFO W, H
            L = LEN(A$)
            BLKSIZE = ( (W*L)*H )\2 + 3
            DIM BLK(0 TO BLKSIZE)
            GETLASTSTRING BLK(0)
            BLKPUT 1, 320, 240, BLK(0)
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END






































                                                                         74





          GETMAXX

            PROTOTYPE

            FUNCTION GETMAXX% ()

            INPUT

            no input parameters

            OUTPUT

            GETMAXX returns the current horizontal resolution of the
            screen.

            USAGE

            GETMAXX returns the horizontal resolution of the screen in the
            current mode.  This function should only be called if one of
            the RES### functions has been previously called.  Otherwise,
            the value returned is meaningless.

            SEE ALSO

            GETMAXY

            EXAMPLE

            REM SHOW GETMAXX
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            X$ = "MAX X SCREEN VALUE IS:" + STR$(GETMAXX)
            DRWSTRING 1, 7, 0, X$, 0, 0
            SETVIEW 0, 0, 400, 479
            X$ = "MAX X SCREEN VALUE IS STILL:" + STR$(GETMAXX)
            DRWSTRING 1, 7, 0, X$, 0, 20
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END












                                                                         75





          GETMAXY

            PROTOTYPE

            FUNCTION GETMAXY% ()

            INPUT

            no input parameters

            OUTPUT

            GETMAXY returns the current vertical resolution of the screen.

            USAGE

            GETMAXY returns the vertical resolution of the screen in the
            current mode.  This function should only be called if one of
            the RES### functions has been previously called.  Otherwise,
            the value returned is meaningless.

            SEE ALSO

            GETMAXX

            EXAMPLE

            REM SHOW GETMAXY
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            Y$ = "MAX Y SCREEN VALUE IS:" + STR$(GETMAXY)
            DRWSTRING 1, 7, 0, Y$, 0, 0
            SETVIEW 0, 0, 639, 200
            Y$ = "MAX Y SCREEN VALUE IS STILL:" + STR$(GETMAXY)
            DRWSTRING 1, 7, 0, Y$, 0, 20
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END













                                                                         76





          GETPOINT

            PROTOTYPE

            FUNCTION GETPOINT% (X%, Y%)

            INPUT

            X, Y - location of pixel to read

            OUTPUT

            GETPOINT returns the color index of pixel at X, Y.

            USAGE

            GETPOINT returns the value of the pixel at location X, Y.
            This value is a color index into the current palette.

            SEE ALSO

            DRWPOINT

            EXAMPLE

            REM DRAW A POINT AND CHECK TO MAKE SURE IT IS THERE
            REM $INCLUDE: 'SVGABC.BI'

            DEFINT A-Z
            IF WHICHVGA = 0 THEN STOP
            IF WHICHMEM < 512 THEN STOP
            VMODE = VIDEOMODEGET
            DUMMY=RES640
            DRWPOINT 1, 10, 320, 240
            POINTVALUE = GETPOINT(320, 240)
            A$ = "THE POINT VALUE IS:" + STR$(POINTVALUE)
            DRWSTRING 1, 7, 0, A$, 0, 0
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END















                                                                         77





          GETSIN

            PROTOTYPE

            FUNCTION GETSIN& (Angle&)

            INPUT

            Angle - angle in degrees

            OUTPUT

            GETSIN returns the sine of Angle scaled up by 13 bits (8192).

            USAGE

            GETSIN returns the sine of the specified angle.  Angle can be
            any long value; floating point values are ignored.  The return
            value has been multiplied by 8192.  This function uses an
            integer lookup table stored within the library in order to
            produce the fastest possible results.  No floating point
            arithmetic is used.  The scale factor of 13 bits (8192) was
            chosen because this is the number of bits at which every
            change of one degree gives a change in the value of the sine
            (or cosine) function.

            SEE ALSO

            GETARCCOS, GETARCSIN, GETARCTAN, GETCOS, GETTAN

            EXAMPLE

            REM SHOW GETSIN
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            DRWBOX 1, 10, 0, 0, 639, 479
            DRWLINE 1, 10, 0, 240, 639, 240
            DRWLINE 1, 10, 320, 0, 320, 479
            DEG2RAD! = 4 * ATN(1) / 180
            FOR I = -360 TO 360
               Y1& = GETSIN(I)
               Y1& = Y1& * 240 / 8192
               Y2& = 240 * SIN(I * DEG2RAD!)
               DRWPOINT 1, 15, 320 + I, 240 - Y1&
               DRWPOINT 1, 12, 320 + I, 240 - Y2&
            NEXT I
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END


                                                                         78





          GETTAN

            PROTOTYPE

            FUNCTION GETTAN& (Angle%)

            INPUT

            Angle - angle in degrees

            OUTPUT

            GETTAN returns the tangent of Angle scaled up by 13 bits
            (8192).

            USAGE

            GETTAN returns the tangent of the specified angle.  Angle can
            be any long value except +(90+n*180), where n is an integer.
            Floating point values are ignored.  The return value has been
            multiplied by 8192.  If an invalid angle is given, the GETTAN
            will return &H80000000 (-2147483648).  This function uses an
            integer lookup table stored within the library in order to
            produce the fastest possible results.  No floating point
            arithmetic is used.  The scale factor of 13 bits (8192) was
            chosen because this is the number of bits at which every
            change of one degree gives a change in the value of the sine
            (or cosine) function.

            SEE ALSO

            GETARCCOS, GETARCSIN, GETARCTAN, GETCOS, GETSIN

            EXAMPLE

            REM SHOW GETTAN
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES640
            DRWBOX 1, 10, 0, 0, 639, 479
            DRWLINE 1, 10, 0, 240, 639, 240
            DRWLINE 1, 10, 320, 0, 320, 479
            DEG2RAD! = 4 * ATN(1) / 180
            FOR I = -360 TO 360
               IF ((I - 90) / 180) <> INT((I - 90) / 180) THEN
                 Y1& = GETTAN(I)
                 Y1& = Y1& * 240 / 8192
                 Y2& = 240 * TAN(I * DEG2RAD!)
                 DRWPOINT 1, 15, 320 + I, 240 - Y1&
                 DRWPOINT 1, 12, 320 + I, 240 - Y2&
               END IF


                                                                         79





            NEXT I
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END



















































                                                                         80





           JOYSTICKINFO

            PROTOTYPE

            SUB JOYSTICKINFO (JAX%, JAY%, JAButs%, JBX%, JBY%, JBButs%)

            INPUT

            no input parameters

            OUTPUT

            no value returned
            JAX, JAY - horizontal and vertical values of joystick A
            JAButs - button status of joystick A
            JBX, JBY - horizontal and vertical values of joystick B
            JBButs - button status of joystick B

            USAGE

            JOYSTICKINFO returns the current status of the two joysticks'
            position and buttons.  The position is returned in JAX, JAY
            for joystick A and JBX, JBY for joystick B.  The buttons'
            status is held in JAButs and JBButs.  For each joystick,
            button A - usually the fire button - is held in bit zero and
            button B is in bit one.  Button status is most easily checked
            with a bitwise AND of JAButs (or JBButs) and the desired bit.

            Not all joysticks are constructed the same.  In addition,
            joysticks are not linear devices.  The value of its center
            will not necessarily be the mean of its extreme values.
            Therefore, it is recommended that any program using the
            joystick for more than just directional control complete a
            calibration of the joystick prior to usage.  For an example of
            joystick calibration, see the SVGADEMO.EXE source code.

            SEE ALSO

            WHICHJOYSTICK

            EXAMPLE

            REM DISPLAY THE STATUS OF THE JOYSTICK PORT
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            CLS
            WHILE INKEY$ = ""
               JOYSTICKINFO JAX, JAY, JAButs, JBX, JBY, JBButs
               LOCATE 1, 1
               PRINT STRING$(40, 32)
               LOCATE 1, 1
               PRINT JAX; JAY; JAButs, JBX; JBY; JBButs;
               SDELAY 4


                                                                         81





            WEND
            END






















































                                                                         82





          MOUSEBUTPRESS

            PROTOTYPE

            SUB MOUSEBUTPRESS (ReqButton%, X%, Y%, Num%, MouseButs%)

            INPUT

            ReqButton - button for which information is requested

            OUTPUT

            no value returned
            X, Y - current location of mouse cursor
            Num - number of times button has been pressed since last
            request
            MouseButs - current status of the mouse buttons

            USAGE

            MOUSEBUTPRESS returns in Num the number of times a mouse
            button has been pressed since the last call to MOUSEBUTPRESS.
            In addition the current status of the mouse cursor and buttons
            is returned.  The position is returned in X, Y.  The buttons'
            status is held in MouseButs.  The left button is held in bit
            zero, right button in bit one and center button - for three
            button mice - in bit two.  Button status is most easily
            checked with a bitwise AND of MouseButs and the desired bit.
            The button for which a history is desired is identified by the
            bits in ReqButton.  However, only one bit may be set.
            Therefore, only the values of 1, 2 and 4 are permitted.  If
            more than one bit in ReqButton is set, the function will exit
            and no information will be returned.

            SEE ALSO

            MOUSEBUTRELEASE, MOUSESTATUS

            EXAMPLE

            REM ENABLE, SHOW, MOUSE / DISPLAY LEFT BUTTON PRESS HISTORY
            REM FOR THE LAST 2 SECONDS
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            IF WHICHMOUSE = 0 THEN STOP
            DUMMY=RES640
            MOUSEENTER
            MOUSESHOW
            WHILE INKEY$ = ""
               MOUSEBUTPRESS 1, X, Y, N, MBUTS
               D$ = "MX=" + STR$(X)


                                                                         83





               L = LEN(D$)
               IF L < 10 THEN
                 D$ = D$ + STRING$(8 - L, 32)
               END IF
               D$ = D$ + "MY=" + STR$(Y)
               L = LEN(D$)
               IF L < 20 THEN
                 D$ = D$ + STRING$(16 - L, 32)
               END IF
               D$ = D$ + "Number Of Times=" + STR$(N)
               DRWSTRING 1, 15, 8, D$, 0, 0
               SDELAY 80
            WEND
            MOUSEEXIT
            VIDEOMODESET VMODE
            END








































                                                                         84





          MOUSEBUTRELEASE

            PROTOTYPE

            SUB MOUSEBUTRELEASE (ReqButton%, X%, Y%, Num%, MouseButs%)

            INPUT

            ReqButton - button for which information is requested

            OUTPUT

            no value returned
            X, Y - current location of mouse cursor
            Num - number of times button has been released since last
            request
            MouseButs - current status of mouse buttons

            USAGE

            MOUSEBUTRELEASE returns in Num the number of times a mouse
            button has been released since the last call to
            MOUSEBUTRELEASE.  In addition the current status of the mouse
            cursor and buttons is returned.  The position is returned in
            X, Y.  The buttons' status is held in MouseButs.  The left
            button is held in bit zero, right button in bit one and center
            button - for three button mice - in bit two.  Button status is
            most easily checked with a bitwise AND of MouseButs and the
            desired bit.  The button for which a history is desired is
            identified by the bits in ReqButton.  However, only one bit
            may be set.  Therefore, only the values of 1, 2 and 4 are
            permitted.  If more than one bit in ReqButton is set, the
            function will exit and no information will be returned.

            SEE ALSO

            MOUSEBUTPRESS, MOUSESTATUS

            EXAMPLE

            REM ENABLE, SHOW, MOUSE / DISPLAY LEFT BUTTON RELEASE HISTORY
            REM FOR THE LAST 2 SECONDS
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            IF WHICHMOUSE = 0 THEN STOP
            DUMMY=RES640
            MOUSEENTER
            MOUSESHOW
            WHILE INKEY$ = ""
               MOUSEBUTRELEASE 1, X, Y, N, MBUTS
               D$ = "MX=" + STR$(X)


                                                                         85





               L = LEN(D$)
               IF L < 10 THEN
               D$ = D$ + STRING$(8 - L, 32)
               END IF
               D$ = D$ + "MY=" + STR$(Y)
               L = LEN(D$)
               IF L < 20 THEN
                 D$ = D$ + STRING$(16 - L, 32)
               END IF
               D$ = D$ + "Number Of Times=" + STR$(N)
               DRWSTRING 1, 15, 8, D$, 0, 0
               SDELAY 80
            WEND
            MOUSEEXIT
            VIDEOMODESET VMODE
            END








































                                                                         86





          MOUSECURSORDEFAULT

            PROTOTYPE

            SUB MOUSECURSORDEFAULT ()

            INPUT

            no input parameters

            OUTPUT

            no value returned

            USAGE

            MOUSECURSORDEFAULT defines the mouse cursor to be a small
            arrow with the hot spot in the upper, left corner.  This is
            the cursor set when MOUSEENTER is called.

            SEE ALSO

            MOUSECURSORSET, MOUSEENTER

            EXAMPLE

            See MOUSECURSORSET





























                                                                         87





          MOUSECURSORSET

            PROTOTYPE

            SUB MOUSECURSORSET (MouseCursor$)

            INPUT

            MouseCursor$ - string * 386 containing mouse cursor data

            OUTPUT

            no value returned

            USAGE

            MOUSECURSORSET defines the cursor according to the data in
            MouseCursor$.  The hot spot X and Y location for the cursor is
            defined by the first two bytes of MouseCursor$.  The values
            for the hot spot must be within the cursor.  Valid values are
            from 0 to 15 for the X location and from 0 to 23 for the Y
            location.

            SEE ALSO

            MOUSECURSORDEFAULT, MOUSEENTER, MOUSESHOW

            EXAMPLE

            REM MAKE A BIG CURSOR, THEN RESTORE IT BACK TO THE DEFAULT
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            IF WHICHMEM < 512 THEN STOP
            IF WHICHMOUSE = 0 THEN STOP
            DUMMY=RES640
            MOUSEENTER
            DIM BIGMOUSECURSOR AS STRING * 386
            FOR I = 1 TO 386
               READ A
               MID$(BIGMOUSECURSOR, I, 1) = CHR$(A)
            NEXT I
            MOUSECURSORSET BIGMOUSECURSOR
            MOUSERANGESET 0, 0, 639, 400
            MOUSESHOW
            A$ = "Press A Key To Return To The Default Cursor"
            DRWSTRING 1, 7, 0, A$, 0, 420
            WHILE INKEY$ = ""
            WEND
            MOUSECURSORDEFAULT
            A$ = "Press A Key To End                         "
            DRWSTRING 1, 7, 0, A$, 0, 420


                                                                         88





            WHILE INKEY$ = ""
            WEND
            MOUSEEXIT
            VIDEOMODESET VMODE
            END

            REM *BIG ARROW MOUSE CURSOR DATA
            DATA 2,2
            DATA 0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255
            DATA 0,15,15,0,0,255,255,255,255,255,255,255,255,255,255,255
            DATA 0,15,15,15,15,0,0,0,255,255,255,255,255,255,255,255
            DATA 0,15,15,15,15,15,15,15,0,0,255,255,255,255,255,255
            DATA 0,15,15,15,15,15,15,15,15,15,0,0,0,255,255,255
            DATA 0,15,15,15,15,15,15,15,15,15,15,15,15,0,0,255
            DATA 0,15,15,15,15,15,15,15,15,15,15,15,15,15,0,255
            DATA 0,15,15,15,15,15,15,15,15,15,15,15,0,0,255,255
            DATA 0,15,15,15,15,15,15,15,15,15,15,0,255,255,255,255
            DATA 0,15,15,15,15,15,15,15,15,0,0,255,255,255,255,255
            DATA 0,15,15,15,15,15,15,15,15,0,255,255,255,255,255,255
            DATA 0,15,15,15,15,15,0,15,15,15,0,255,255,255,255,255
            DATA 0,15,15,15,15,0,0,15,15,15,0,255,255,255,255,255
            DATA 0,15,15,0,0,255,255,0,15,15,15,0,255,255,255,255
            DATA 0,15,0,255,255,255,255,0,15,15,15,0,255,255,255,255
            DATA 0,0,255,255,255,255,255,255,0,15,15,15,0,255,255,255
            DATA 255,255,255,255,255,255,255,255,255,0,15,15,15,0,255,255
            DATA 255,255,255,255,255,255,255,255,255,0,15,15,15,0,255,255
            DATA 255,255,255,255,255,255,255,255,255,255,0,15,15,15,0,255
            DATA 255,255,255,255,255,255,255,255,255,255,255,0,15,15,15,0
            DATA 255,255,255,255,255,255,255,255,255,255,255,0,15,15,15,0
            DATA 255,255,255,255,255,255,255,255,255,255,255,255,0,15,15,0
            DATA 255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0
            DATA
            255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,25
            5






















                                                                         89





          MOUSEENTER

            PROTOTYPE

            SUB MOUSEENTER ()

            INPUT

            no input parameters

            OUTPUT

            no value returned

            USAGE

            MOUSEENTER must be called before any other mouse functions.
            It initializes all of the mouse abilities including installing
            the Zephyr mouse display driver.  MOUSEENTER initializes the
            default mouse cursor, the default sensitivity and sets the
            range to the current screen resolution.  The mouse cursor
            location is set to the middle of the screen.

            SEE ALSO

            MOUSEEXIT, MOUSEHIDE, MOUSESHOW

            EXAMPLE

            REM ENABLE AND SHOW THE MOUSE
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            IF WHICHMOUSE = 0 THEN STOP
            DUMMY=RES640
            MOUSEENTER
            MOUSESHOW
            WHILE INKEY$ = ""
            WEND
            MOUSEEXIT
            VIDEOMODESET VMODE
            END












                                                                         90





          MOUSEEXIT

            PROTOTYPE

            SUB MOUSEEXIT ()

            INPUT

            no input parameters

            OUTPUT

            no value returned

            USAGE

            MOUSEEXIT properly disables all of the mouse abilities.  This
            function also removes the Zephyr mouse display driver.  This
            function should be called prior to exiting any program that
            previously called MOUSEENTER.

            SEE ALSO

            MOUSEENTER, MOUSEHIDE, MOUSESHOW

            EXAMPLE

            See MOUSEENTER




























                                                                         91





          MOUSEHIDE

            PROTOTYPE

            SUB MOUSEHIDE ()

            INPUT

            no input parameters

            OUTPUT

            no value returned

            USAGE

            MOUSEHIDE turns off the mouse display driver and removes the
            cursor from the display.  It is recommended to hide the mouse
            any time something will be drawn in its general vicinity.
            Note, however, that although the cursor is not visible, all
            other mouse abilities remain active.

            SEE ALSO

            MOUSEENTER, MOUSEEXIT, MOUSESHOW

            EXAMPLE

            REM ENABLE, SHOW, AND THE HIDE THE MOUSE
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            IF WHICHMOUSE = 0 THEN STOP
            DUMMY=RES640

            MOUSEENTER
            MOUSESHOW
            WHILE INKEY$ = ""
            WEND
            MOUSEHIDE

            WHILE INKEY$ = ""
            WEND
            MOUSEEXIT
            VIDEOMODESET VMODE

            END







                                                                         92





          MOUSEINFO

            PROTOTYPE

            SUB MOUSEINFO (MajorVersion%, MinorVersion%, MouseType%, IRQ%)

            INPUT

            no input parameters

            OUTPUT

            no value returned
            MajorVersion - Microsoft compatible mouse driver major version
            number
            MinorVersion - Microsoft compatible mouse driver minor version
            number
            MouseType - type of mouse installed
            IRQ - the interrupt used by the mouse

            USAGE

            MOUSEINFO returns information about the mouse and its
            installed driver.  The driver must be Microsoft compatible.
            This information can be used to determine whether the mouse
            functions in this library will operate correctly.  For proper
            operation the driver version number must be greater than 1.00.
            IRQ gives the interrupt number of the mouse - probably 3 or 4.
            MouseType returns information about the type of hardware
            installed according to the following table:

            0 =  unknown type
            1 =  bus mouse
            2 =  serial mouse
            3 =  Inport mouse
            4 =  PS/2 mouse
            5 =  HP mouse

            SEE ALSO

            WHICHMOUSE

            EXAMPLE

            REM RETURN INFORMATION ABOUT THE MOUSE
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            CLS
            MOUSE = WHICHMOUSE
            IF MOUSE > 0 THEN
               MOUSEINFO MJV, MNV, TP, I
               VER$ = STR$(MNV)
               L = LEN(VER$)


                                                                         93





               VER$ = STR$(MJV) + "." + RIGHT$(VER$, L - 1)
               VER$ = "Software driver version is" + VER$
               VER$ = VER$ + " (Microsoft equivalent version)."
               SELECT CASE TP
                 CASE IS = 1
                    TYPE$ = "bus mouse"
                 CASE IS = 2
                    TYPE$ = "serial mouse"
                 CASE IS = 3
                    TYPE$ = "Inport mouse"
                 CASE IS = 4
                    TYPE$ = "PS/2 mouse"
                 CASE IS = 5
                    TYPE$ = "HP mouse"
                 CASE ELSE
                    TYPE$ = "unknown type"
               END SELECT
               PRINT "Microsoft compatible " + TYPE$ + " detected with";
               PRINT STR$(MOUSE) + " buttons on IRQ" + STR$(I) + "."
               PRINT VER$
            ELSE
               PRINT "No Microsoft compatible mouse detected."
            END IF
            PRINT
            WHILE INKEY$ = ""
            WEND
            END





























                                                                         94





          MOUSELOCSET

            PROTOTYPE

            SUB MOUSELOCSET (X%, Y%)

            INPUT

            X, Y - location on screen

            OUTPUT

            no value returned

            USAGE

            MOUSELOCSET moves the mouse cursor the location on the screen
            specified by X, Y.  If either X or Y is outside of the
            currently permitted mouse range, it is set to the closest
            border.  The currently permitted mouse range is the current
            screen resolution or the last called MOUSERANGESET.

            SEE ALSO

            MOUSEENTER, MOUSERANGESET

            EXAMPLE

            REM ENABLE AND SHOW THE MOUSE THEN MOVE IT TO THE ORIGIN
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            IF WHICHMOUSE = 0 THEN STOP
            DUMMY=RES640
            MOUSEENTER
            MOUSESHOW
            WHILE INKEY$ = ""
            WEND
            MOUSELOCSET 0, 0
            WHILE INKEY$ = ""
            WEND
            MOUSEEXIT
            VIDEOMODESET VMODE
            END










                                                                         95





          MOUSERANGESET

            PROTOTYPE

            SUB MOUSERANGESET (X1%, Y1%, X2%, Y2%)

            INPUT

            X1, Y1 - location on screen of top, left corner of range
            X2, Y2 - location on screen of bottom, right corner of range

            OUTPUT

            no value returned

            USAGE

            MOUSERANGESET defines a permissible range on the screen for
            mouse movement.  The mouse is automatically positioned in the
            center of this range.

            SEE ALSO

            MOUSELOCSET, MOUSESTATUS

            EXAMPLE

            REM ENABLE, SHOW, AND SET A RANGE FOR THE MOUSE
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            IF WHICHMOUSE = 0 THEN STOP
            DUMMY=RES640
            MOUSEENTER
            DRWBOX 1, 10, 100, 100, 539, 379
            MOUSERANGESET 100, 100, 539, 379
            MOUSESHOW
            WHILE INKEY$ = ""
            WEND
            MOUSEEXIT
            VIDEOMODESET VMODE
            END












                                                                         96





          MOUSERESTORESTATE

            PROTOTYPE

            SUB MOUSERESTORESTATE (MouseBuf%)

            INPUT

            MouseBuf - integer array holding complete mouse status
            information

            OUTPUT

            no value returned

            USAGE

            MOUSERESTORESTATE completely restores a previously saved mouse
            status as contained in MouseBuf.  The mouse status must have
            been already stored in MouseBuf by MOUSESAVESTATE.

            SEE ALSO

            MOUSESAVESTATE, MOUSESTORAGESIZE

            EXAMPLE

            REM SAVE THE CURRENT MOUSE DRIVER STATUS,SHELL OUT, RESTORE IT
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            IF WHICHMOUSE = 0 THEN STOP
            BUFSIZE = MOUSESTORAGESIZE \ 2 + 1
            DIM MBUFFER(0 TO BUFSIZE) AS INTEGER
            MOUSESAVESTATE MBUFFER(0)
            PRINT "TYPE 'EXIT' TO RETURN TO THE PROGRAM"
            SHELL
            CLS
            MOUSERESTORESTATE MBUFFER(0)
            PRINT "DRIVER RESTORED..."
            WHILE INKEY$ = ""
            WEND
            END













                                                                         97





          MOUSESAVESTATE

            PROTOTYPE

            SUB MOUSESAVESTATE (MouseBuf%)

            INPUT

            no input parameters

            OUTPUT

            no value returned
            MouseBuf - integer array holding complete mouse status
            information

            USAGE

            MOUSESAVESTATE saves the complete mouse status in MouseBuf.
            The size of MouseBuf in bytes is defined by MOUSESTORAGESIZE
            which should called first.

            SEE ALSO

            MOUSERESTORESTATE, MOUSESTORAGESIZE

            EXAMPLE

            See MOUSERESTORESTATE



























                                                                         98





          MOUSESENSSET

            PROTOTYPE

            SUB MOUSESENSSET (XSens%, Ysens%, DblSpdTresh%)

            INPUT

            XSens - number of mickeys per 8 pixels horizontally (default =
            4 mickeys per pixel)
            YSens - number of mickeys per 8 pixels vertically (default = 4
            mickeys per pixel)
            DblSpdThresh = number of mickeys per second at which speed is
            doubled (default = 8)

            OUTPUT

            no value returned

            USAGE

            MOUSESENSSET defines the relationship between mouse movement
            and cursor movement on the screen.  A mickey is defined as
            1/200th of an inch.  The ratio between mickeys and pixels is
            specified by XSens and YSens in the horizontal and vertical
            directions respectively.  When the mouse movement is faster
            than DblSpdThresh in mickeys per second, the speed is doubled.
            The default values are assigned whenever MOUSEENTER is called.

            SEE ALSO

            MOUSEENTER, MOUSEEXIT, MOUSESTATUS

            EXAMPLE

            REM ENABLE, SHOW THE MOUSE AND MAKE IT VERY SENSITIVE
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            IF WHICHMOUSE = 0 THEN STOP
            DUMMY=RES640
            MOUSEENTER
            MOUSESHOW
            MOUSESENSSET 2, 2, 4
            WHILE INKEY$ = ""
            WEND
            MOUSEEXIT
            VIDEOMODESET VMODE
            END





                                                                         99





          MOUSESHOW

            PROTOTYPE

            SUB MOUSESHOW ()

            INPUT

            no input parameters

            OUTPUT

            no value returned

            USAGE

            MOUSESHOW enables the mouse display driver and places the
            cursor on the screen.  The cursor is only updated when the
            mouse is moved.  Therefore, it is recommended to hide the
            cursor when drawing on the screen to avoid unexpected results.

            SEE ALSO

            MOUSEENTER, MOUSEEXIT, MOUSEHIDE

            EXAMPLE

            See MOUSEHIDE




























                                                                        100





          MOUSESTATUS

            PROTOTYPE

            SUB MOUSESTATUS (X%, Y%, MouseButs%)

            INPUT

            no input parameters

            OUTPUT

            no value returned
            X, Y - mouse position on screen
            MouseButs - status of mouse buttons

            USAGE

            MOUSESTATUS returns the current status of the mouse position
            and buttons.  The position is returned in X, Y.  The buttons'
            status is held in MouseButs.  The left button is held in bit
            zero, right button in bit one and center button - for three
            button mice - in bit two.  Button status is most easily
            checked with a bitwise AND of MouseButs and the desired bit.

            SEE ALSO

            MOUSERANGESET, MOUSESENSSET

            EXAMPLE

            REM ENABLE, SHOW, DISPLAY MOUSE STATUS
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z
            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            IF WHICHMOUSE = 0 THEN STOP
            DUMMY=RES640
            MOUSEENTER
            MOUSESHOW
            WHILE INKEY$ = ""
               MOUSESTATUS X, Y, MButs
               D$ = "MX=" + STR$(X)
               L = LEN(D$)
               IF L < 10 THEN
                 D$ = D$ + STRING$(8 - L, 32)
               END IF
               D$ = D$ + "MY=" + STR$(Y)
               L = LEN(D$)
               IF L < 20 THEN
                 D$ = D$ + STRING$(16 - L, 32)
               END IF
               D$ = D$ + "MBUTS=" + STR$(MButs)
               DRWSTRING 1, 15, 8, D$, 0, 0


                                                                        101





            WEND
            MOUSEEXIT
            VIDEOMODESET VMODE
            END




















































                                                                        102





          MOUSESTORAGESIZE

            PROTOTYPE

            FUNCTION MOUSESTORAGESIZE% ()

            INPUT

            no input parameters

            OUTPUT

            MOUSESTORAGESIZE returns the number of bytes needed to store
            the complete mouse status.

            USAGE

            MOUSESTORAGESIZE determines the proper size buffer to hold the
            complete mouse status information.  This buffer should be
            created before calling MOUSESAVESTATE.

            SEE ALSO

            MOUSERESTORESTATE, MOUSESAVESTATE

            EXAMPLE

            REM RETURN THE SIZE IN BYTES NEEDED TO SAVE THE MOUSE STATUS
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            CLS
            IF WHICHMOUSE = 0 THEN STOP
            A$ = "The Mouse Driver Requires A" + STR$(MOUSESTORAGESIZE) +
            " Byte Buffer "
            A$ = A$ + "To Save Current Status."
            PRINT A$
            PRINT
            WHILE INKEY$ = ""
            WEND
            END















                                                                        103





          OVERSCANSET

            PROTOTYPE

            SUB OVERSCANSET (Color%)

            INPUT

            Color - index to color in current palette

            OUTPUT

            no value returned

            USAGE

            OVERSCANSET sets the overscan region to the specified color.
            The overscan region is the area between the usable pixel area
            and the region not scanned by the monitor.  Normally, the
            overscan is color zero which is defined as black the majority
            of the time.  The overscan color is reset to zero anytime a
            RES### function is called.

            Note: OVERSCANSET always works in the 320x200 resolution.  In
            the higher resolutions on many common SVGA cards this function
            is ignored.  Instead, the card always assigns the overscan
            region to color zero.  Therefore, it is recommended to not use
            OVERSCANSET, but assign color zero as needed.

            EXAMPLE

            REM SET THE OVERSCAN COLOR TO GREEN
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z
            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            RES320
            OVERSCANSET 10
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END














                                                                        104





          PAGEACTIVE

            PROTOTYPE

            FUNCTION PAGEACTIVE (Page%)

            INPUT

            Page - number of page to make active

            OUTPUT

            PAGEACTIVE returns a 1 if successful, 0 if unsuccessful.

            USAGE

            PAGEACTIVE sets the active page as specified by Page.  It
            works by creating an offset to be added when any bank
            switching is performed.  This function does not affect the
            actual display.  A page is defined as the number of 64K blocks
            necessary to contain the current screen resolution.  For
            example, 640x480 requires 307,200 bytes which is a little more
            than 4.5 64K blocks.  One page in this resolution will be 5
            banks.

            PAGEACTIVE does not work in 320x200 mode since this mode uses
            no bank switching.

            SEE ALSO

            PAGEDISPLAY

            EXAMPLE

            REM SHOW PAGEACTIVE FUNCTION
            REM THIS EXAMPLE REQUIRES 1 MEG OF VIDEO MEMORY
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            IF WHICHVGA = 0 THEN
               END
            END IF
            IF WHICHMEM < 1024 THEN
               END
            END IF
            IF RES640 = 0 THEN
               END
            END IF

            REM MAKE SURE VIDEO CARD SUPPORTS PAGE FLIPPING
            IF PAGEDISPLAY(0, 0, 0) = 0 THEN
               DUMMY = RESTEXT
            END
            END IF


                                                                        105





            DUMMY = PAGEACTIVE(0)
            FILLPAGE 0
            DRWSTRING 1, 10, 0, "PAGE 0", 0, 0
            DRWSTRING 1, 10, 0, "PRESS A KEY...", 0, 300
            DUMMY = PAGEACTIVE(1)
            FILLPAGE 0
            DRWSTRING 1, 12, 0, "PAGE 1", 0, 20
            DRWSTRING 1, 12, 0, "PRESS A KEY...", 0, 300
            DUMMY = PAGEACTIVE(2)
            FILLPAGE 0
            DRWSTRING 1, 13, 0, "PAGE 2", 0, 40
            DRWSTRING 1, 13, 0, "PRESS A KEY...", 0, 300
            DUMMY = PAGEDISPLAY(0, 0, 0)
            WHILE INKEY$ = ""
            WEND
            DUMMY = PAGEDISPLAY(0, 0, 1)
            WHILE INKEY$ = ""
            WEND
            DUMMY = PAGEDISPLAY(0, 0, 2)
            WHILE INKEY$ = ""
            WEND
            DUMMY = RESTEXT
            CLS
            END
































                                                                        106





          PAGEDISPLAY

            PROTOTYPE

            FUNCTION PAGEDISPLAY (X%, Y%, Page%)

            INPUT

            X, Y - coordinate to place at top, left of display
            Page - number of page to make active

            OUTPUT

            PAGEACTIVE returns a 1 if successful, 0 if unsuccessful.

            USAGE

            PAGEDISPLAY tells the video card where in video memory to
            begin the display.  This display offset is calculated from the
            specified Page, X and Y.  This is done by multiplying Y times
            the width of the current resolution, adding X and then adding
            the appropriate number of 64K blocks for Page.  X, Y and Page
            must all be positive numbers, but are otherwise not
            restricted.  The display will wrap if the values are
            abnormally large.  Wrapping will happen from side to side as
            well as from top of memory to bottom of memory.

            PAGEDISPLAY does not work in 320x200 mode since this mode uses
            no bank switching.  In addition, older models of some SVGA
            cards operating in native mode do not support paging.  In this
            library these cards are: Acumos, Ahead version A, Everex and
            Genoa.  To ensure compatibility, a program should make a call
            similar to:

            RET = PAGEDISPLAY(0,0,0)
            IF RET = 0 THEN PRINT "PAGING NOT SUPPORTED"

            Note: SVGA cards by ATI Technologies appear to ignore bit 4
            (counting from 0 to 19) in its linear addressing mode and
            assume it is zero.  Therefore, bit 4 of the x parameter will
            be ignored by ATI chipsets.

            SEE ALSO

            PAGEACTIVE

            EXAMPLE

            See PAGEACTIVE







                                                                        107





          PALCHGAUTO

            PROTOTYPE

            SUB PALCHGAUTO (Pal$, NewPal$, FirstColor%, LastColor%,
            Speed%)

            INPUT

            Pal$ - string * 768 containing initial palette
            NewPal$ - string *768 containing new palette
            FirstColor - index into palette where change will begin
            LastColor - index into palette where change will end
            Speed - speed of change

            OUTPUT

            no value returned

            USAGE

            PALCHGAUTO smoothly fades the colors between FirstColor and
            LastColor from the palette Pal$ to NewPal$.  The speed of the
            fade is set by Speed which is percentage change between each
            step of the fade.  Only values between 1 and 128 are valid
            where 1 represents a one percent change between steps and 128
            (80 hex) represents fifty percent change between steps.  A
            Speed of 128 would then have only two steps.  A Speed outside
            of the valid range causes the function to immediately return
            without making any changes.  The time required to accomplish
            the entire fade is approximately equal to 0.033 seconds times
            256 divided by Speed.  PALCHGAUTO does not modify either Pal$
            or NewPal$.

            SEE ALSO

            PALCHGSTEP, PALDIMSTEP, PALIOAUTO

            EXAMPLE

            REM AUTOFADE FROM ONE PALETTE TO ANOTHER AND BACK AGAIN
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z
            DIM PAL AS STRING * 768
            DIM NEWPAL AS STRING * 768

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            IF WHICHMEM < 512 THEN STOP
            DUMMY=RES640
            PALGET PAL, 0, 255
            FOR I = 1 TO 768
               MID$(NEWPAL, I, 1) = MID$(PAL, 769 - I, 1)
            NEXT I


                                                                        108





            COLR = 0
            FOR I = 0 TO 639
               DRWLINE 1, COLR, I, 0, I, 479
               COLR = COLR + 1
               IF COLR > 255 THEN
                 COLR = 0
               END IF
            NEXT I
            PALCHGAUTO PAL, NEWPAL, 0, 255, 2
            PALCHGAUTO NEWPAL, PAL, 0, 255, 2
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END










































                                                                        109





          PALCHGSTEP

            PROTOTYPE

            SUB PALCHGSTEP (Pal$, NewPal$, FirstColor%, LastColor%,
            Percent%)

            INPUT

            Pal$ - string * 768 containing initial palette
            NewPal$ - string * 768 containing new palette
            FirstColor - index into palette where change will begin
            LastColor - index into palette where change will end
            Percent - percent step from current palette to new palette

            OUTPUT

            no value returned

            USAGE

            PALCHGSTEP changes the palette colors between FirstColor and
            LastColor by Percent from Pal$ to NewPal$.  This function
            works very much like PALCHGAUTO except it only takes a single
            step and returns.  The step taken is a percentage specified by
            Percent where 256 (100 hex) is a 100 percent change.  The
            valid range for Percent is 0 to 256.  Values beyond this range
            cause the function to immediately return without making any
            changes.  A loop from 4 to 256 by fours using PALCHGSTEP would
            have similar results as PALCHGAUTO with a speed of 4.  Neither
            Pal$, nor NewPal$ are modified.

            SEE ALSO

            PALCHGAUTO, PALDIMSTEP, PALIOAUTO

            EXAMPLE

            REM STEP FADE FROM ONE PALETTE TO ANOTHER AND BACK AGAIN FAST
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z
            DIM PAL AS STRING * 768
            DIM NEWPAL AS STRING * 768

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            IF WHICHMEM < 512 THEN STOP
            DUMMY=RES640
            PALGET PAL, 0, 255
            FOR I = 1 TO 768
               MID$(NEWPAL, I, 1) = MID$(PAL, 769 - I, 1)
            NEXT I
            COLR = 0
            FOR I = 0 TO 639


                                                                        110





               DRWLINE 1, COLR, I, 0, I, 479
               COLR = COLR + 1
               IF COLR > 255 THEN
                 COLR = 0
               END IF
            NEXT I
            FOR I = 1 TO 255 STEP 2
               PALCHGSTEP PAL, NEWPAL, 0, 255, I
            NEXT I
            FOR I = 1 TO 255 STEP 16
               PALCHGSTEP NEWPAL, PAL, 0, 255, I
            NEXT I
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END








































                                                                        111





          PALCOPY

            PROTOTYPE

            SUB PALCOPY (SrcPalette$, DestPalette$, FirstColor%,
            LastColor%)

            INPUT

            SrcPalette$ - string * 768 containing source palette
            FirstColor - index into palette where copy will begin
            LastColor - index into palette where copy will end

            OUTPUT

            no value returned
            DestPalette$ - string * 768 containing copy of source palette

            USAGE

            PALCOPY quickly copies a source palette into a second palette
            array.  The source and destination must both be defined as
            string * 768 or PALCOPY will return without making any copy.
            A portion of a palette may be copied by specifying first and
            last colors.

            SEE ALSO

            BYTECOPY

            EXAMPLE

            REM SHOW PAL COPY
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z
            DIM PAL1 AS STRING * 768
            DIM PAL2 AS STRING * 768
            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            IF WHICHMEM < 512 THEN STOP
            DUMMY = RES640
            FOR I = 0 TO 255
               MID$(PAL1, I * 3 + 1, 1) = CHR$(I)
               MID$(PAL1, I * 3 + 2, 1) = CHR$(I)
               MID$(PAL1, I * 3 + 3, 1) = CHR$(I)
            NEXT I
            COLR = 0
            FOR I = 0 TO 639
               DRWLINE 1, COLR, I, 0, I, 479
               COLR = COLR + 1
               IF COLR > 255 THEN COLR = 0
            NEXT I
            PALCOPY PAL1, PAL2, 0, 255
            PALSET PAL2, 0, 255


                                                                        112





            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END




















































                                                                        113





          PALDIMSTEP

            PROTOTYPE

            SUB PALDIMSTEP (Pal$, FirstColor%, LastColor%, Percent%)

            INPUT

            Pal$ - string * 768 containing initial palette
            FirstColor - index into palette where dim will begin
            LastColor - index into palette where dim will end
            Percent - percent step from current palette to black

            OUTPUT

            no value returned

            USAGE

            PALDIMSTEP fades the specified palette to black by the given
            percentage between FirstColor and LastColor.  The percentage
            step from Pal$ to black is specified by Percent where 256 (100
            hex) is full black.  The valid range for Percent is 0 to 256.
            Values beyond this range cause the function to immediately
            return without making any changes.  Pal$ is not modified.

            SEE ALSO

            PALCHGAUTO, PALCHGSTEP, PALIOAUTO

            EXAMPLE

            REM STEP FADE OUT AND BACK IN FAST
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z
            DIM PAL AS STRING * 768

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            IF WHICHMEM < 512 THEN STOP
            DUMMY=RES640
            PALGET PAL, 0, 255
            COLR = 0
            FOR I = 0 TO 639
               DRWLINE 1, COLR, I, 0, I, 479
               COLR = COLR + 1
               IF COLR > 255 THEN COLR = 0
            NEXT I
            FOR I = 255 TO 0 STEP -2
               PALDIMSTEP PAL, 0, 255, I
            NEXT I
            FOR I = 1 TO 255 STEP 16
               PALDIMSTEP PAL, 0, 255, I
            NEXT I


                                                                        114





            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END




















































                                                                        115





          PALGET

            PROTOTYPE

            SUB PALGET (Pal$, FirstColor, LastColor%)

            INPUT

            Pal$ - string * 768 to hold current palette
            FirstColor - index into palette where get will begin
            LastColor - index into palette where get will end

            OUTPUT

            Pal$ - string * 768 containing the current palette in the
            specified range

            USAGE

            PALGET returns in Pal$ the colors from the current palette
            between FirstColor and LastColor.  Only colors in the
            specified range are returned and all others in Pal$ are
            unchanged.  Pal$ must have a length of 768 characters despite
            the number of colors retrieved.

            SEE ALSO

            PALROTATE, PALSET

            EXAMPLE

            REM GET THE CURRENT PALETTE IN THE VARIABLE 'PAL'
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z
            DIM PAL AS STRING * 768

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            IF WHICHMEM < 512 THEN STOP
            DUMMY=RES640
            PALGET PAL, 0, 255
            VIDEOMODESET VMODE
            CLS
            PRINT "GOT IT IN 'PAL'..."
            WHILE INKEY$ = ""
            WEND
            END









                                                                        116





          PALIOAUTO

            PROTOTYPE

            SUB PALIOAUTO (Pal$, FirstColor%, LastColor%, Speed%)

            INPUT

            Pal$ - string *768 containing initial palette
            FirstColor - index into palette where fade will begin
            LastColor - index into palette where fade will end
            Speed - speed of fade

            OUTPUT

            no value returned

            USAGE

            PALIOAUTO smoothly fades the colors between FirstColor and
            LastColor of Pal$ to or from solid black.  The speed of the
            fade is set by Speed which is the percentage change between
            each step of the fade.  A positive Speed corresponds to fading
            from Pal$ to black and a negative Speed fades from black to
            Pal$.  Only values between -128 and +128 are valid where  1
            represents a one percent change between steps and  128 ( 80
            hex) represents fifty percent change between steps.  A Speed
            of 128 would then have only two steps.  A Speed outside of the
            valid range causes the function to immediately return without
            making any changes.  The time required to accomplish the
            entire fade is approximately equal to 0.033 seconds times 256
            divided by Speed.  PALIOAUTO does not modify Pal$.

            SEE ALSO

            PALCHGAUTO, PALCHGSTEP, PALDIMSTEP

            EXAMPLE

            REM FADE OUT AND BACK IN FAST
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z
            DIM PAL AS STRING * 768
            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            IF WHICHMEM < 512 THEN STOP
            DUMMY=RES640
            PALGET PAL, 0, 255
            COLR = 0
            FOR I = 0 TO 639
               DRWLINE 1, COLR, I, 0, I, 479
               COLR = COLR + 1
               IF COLR > 255 THEN COLR = 0
            NEXT I


                                                                        117





            PALIOAUTO PAL, 0, 255, -2
            PALIOAUTO PAL, 0, 255, 16
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END


















































                                                                        118





          PALROTATE

            PROTOTYPE

            SUB PALROTATE (Pal$, FirstColor%, LastColor%, Shift%)

            INPUT

            Pal$ - string * 768 containing current palette
            FirstColor - index into palette where shift will begin
            LastColor - index into palette where shift will end
            Shift - number of locations to shift colors

            OUTPUT

            no value returned

            USAGE

            PALROTATE shifts the colors between FirstColor and LastColor
            by a given number of locations.  The number of locations the
            colors are moved is specified by Shift which is between 1 and
            256.  Pal$ is not modified by PALROTATE.

            SEE ALSO

            PALGET, PALSET

            EXAMPLE

            REM ROTATE A FEW PALETTE ENTRIES AROUND
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z
            DIM PAL AS STRING * 768

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            IF WHICHMEM < 512 THEN STOP
            DUMMY=RES640
            PALGET PAL, 0, 255
            COLR = 0
            FOR I = 0 TO 639
               DRWLINE 1, COLR, I, 0, I, 479
               COLR = COLR + 1
               IF COLR > 255 THEN COLR = 0
            NEXT I
            FOR I = 0 TO 100
               PALROTATE PAL, 0, 127, 1
               PALGET PAL, 0, 255
            NEXT I
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END


                                                                        119





          PALSET

            PROTOTYPE

            SUB PALSET (Pal$, FirstColor%, LastColor%)

            INPUT

            Pal$ - string * 768 containing the palette to set
            FirstColor - index into palette where set will begin
            LastColor - index into palette where set will end

            OUTPUT

            no value returned

            USAGE

            PALSET sets the specified range of colors in the current
            palette with the corresponding range in the palette Pal$.

            SEE ALSO

            PALGET

            EXAMPLE

            REM SET A NEW PALETTE
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z
            DIM PAL AS STRING * 768
            DIM NEWPAL AS STRING * 768

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            IF WHICHMEM < 512 THEN STOP
            DUMMY=RES640
            PALGET PAL, 0, 255
            FOR I = 1 TO 768
               MID$(NEWPAL, I, 1) = MID$(PAL, 769 - I, 1)
            NEXT I
            COLR = 0
            FOR I = 0 TO 639
               DRWLINE 1, COLR, I, 0, I, 479
               COLR = COLR + 1
               IF COLR > 255 THEN COLR = 0
            NEXT I
            PALSET NEWPAL, 0, 255
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END




                                                                        120





          PCXGETINFO

            PROTOTYPE

            FUNCTION PCXGETINFO% (Filename$, Width%, Height%, NumColors%,
            Palette$)

            INPUT

            Filename$ - the filename of the PCX image to read

            OUTPUT

            PCXGETINFO returns the status of the function (1 = success).
            Width - the width in pixels of the image
            Height - the height in pixels of the image
            NumColors - the number of colors in the image palette
            Palette$ - string*768 containing the image palette

            USAGE

            PCXGETINFO reads Filename$ and returns the characteristics of
            the image.  The dimensions of the image are returned in Width,
            Height.  The number of colors in the image's palette is
            returned in NumColors and the palette is returned in Palette$.
            Although the image's palette may contain less than 256 colors,
            Palette$ must be 768 characters in length.  The image's
            palette will begin with the first character of Palette$.

            PCX version 3.0 is the only specification for 256 color
            images.  Therefore, only version 3.0 PCX files are accepted.

            If PCXGETINFO determines that Filename$ is a satisfactory
            file, the function will return a one.  Otherwise, the function
            will return one of several error codes concerning Filename$ as
            listed below:

            0 =  does not exist or there is some disk I/O problem
            -1 = not a version 3.0 PCX file
            -2 = not run-length-encoded
            -3 = general error

            SEE ALSO

            PCXMAKE, PCXPUT

            EXAMPLE

            REM GET THE INFORMATION OF THE PCX FILE 'ZEPHYR.PCX'
            REM $INCLUDE: 'SVGABC.BI'

            DEFINT A-Z
            DIM PCXPAL AS STRING * 768



                                                                        121





            DUMMY = WHICHVGA
            CLS
            PCXFILENAME$ = "ZEPHYR.PCX"
            OK = PCXGETINFO(PCXFILENAME$, XSIZE, YSIZE, NUMCOL, PCXPAL)
            IF OK = 1 THEN
               A$ = "'" + PCXFILENAME$ + "' is identified as a PCX file"
               PRINT A$
               A$ = "Dimensions are:" + STR$(XSIZE) + " pixels wide and" +
            STR$(YSIZE)
               A$ = A$ + " pixels high"
               PRINT A$
               A$ = "Number of colors:" + STR$(NUMCOL)
               PRINT A$
            ELSE
               PRINT "There was an error! -"; OK
            END IF
            WHILE INKEY$ = ""
            WEND
            END





































                                                                        122





          PCXMAKE

            PROTOTYPE

            FUNCTION PCXMAKE% (X1%, Y1%, X2%, Y2%, Filename$)

            INPUT

            X1, Y1 - the location of the top, left corner of the image
            X2, Y2 - the bottom, right corner of the image
            Filename$ - filename to store the PCX image

            OUTPUT

            PCXMAKE returns a 1 if successful, 0 if unsuccessful.

            USAGE

            PcxMAKE takes the bitmap enclosed in the box defined by (X1,
            Y1) - (X2, Y2) and writes a PCX file with the filename
            specified by Filename$.  The resulting file uses the version
            3.0 PCX specification.  X1, Y1, X2 and Y2 must be valid
            coordinates on the currently active page.  Filename$ may
            specify a full path and drive letter, if necessary.

            If PCXPUT encounters no problems, the function will return a
            one.  Otherwise, the function will return one of several error
            codes concerning Filename$ as listed below:

            0 =  disk I/O problem
            -1 = coordinates out of range

            SEE ALSO

            PCXGETINFO, PCXPUT

            EXAMPLE

            REM MAKE A 256 COLOR PCX FILE
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z
            IF WHICHCPU < 386 THEN END
            IF WHICHVGA = 0 THEN END

            DUMMY = RES640
            FILLSCREEN 10
            FOR A = 0 TO 200
               X1 = RND * GETMAXX
               Y1 = RND * GETMAXY
               X2 = RND * GETMAXX
               Y2 = RND * GETMAXY
               C = RND * 255
               DRWLINE 1, C, X1, Y1, X2, Y2
            NEXT A


                                                                        123





            DRWBOX 1, 15, 0, 0, GETMAXX, GETMAXY
            A$ = "This PCX file was created using Zephyr Software's
            'PCXMAKE' function!"
            DRWSTRING 1, 15, 0, A$, 2, 2
            ER = PCXMAKE(0, 0, GETMAXX, GETMAXY, "TEST.PCX")
            WHILE INKEY$ = ""
            WEND
            DUMMY = RESTEXT
            IF ER <> 1 THEN
               PRINT "PCX MAKE ERROR! -"; ER
            END IF
            END












































                                                                        124





          PCXPUT

            PROTOTYPE

            FUNCTION PCXPUT (Mode%, X%, Y%, Filename$)

            INPUT

            Mode - pixel write mode (SET=1, XOR=2, OR=3, AND=4)
            X, Y - the location of the top, left corner of the PCX image
            Filename$ - filename of the PCX image to read

            OUTPUT

            PCXPUT returns the status of the function (1 = success).

            USAGE

            PCXPUT reads the PCX image from Filename$ and places it on the
            screen with the top, left corner at X, Y.  The image is
            automatically clipped to the currently defined viewport.  The
            image's palette should be previously obtained by using
            PCXGETINFO.

            PCX version 3.0 is the only specification for 256 color
            images.  Therefore, only version 3.0 PCX files are accepted.

            If PCXPUT encounters no problems, the function will return a
            one.  Otherwise, the function will return one of several error
            codes concerning Filename$ as listed below:

            0 =  does not exist or there is some disk I/O problem
            -1 = not a version 3.0 PCX file
            -2 = not run-length-encoded
            -3 = general error

            SEE ALSO

            PCXGETINFO, PCXMAKE, SETVIEW

            EXAMPLE

            REM DISPLAY THE PCX FILE 'ZEPHYR.PCX'
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            DIM PCXPAL AS STRING * 768

            IF WHICHVGA = 0 THEN END
            PCXFILENAME$ = "ZEPHYR.PCX"
            IF RES640 = 0 THEN END

            OK = PCXGETINFO(PCXFILENAME$, XSIZE, YSIZE, NUMCOL, PCXPAL)
            IF OK = 1 THEN


                                                                        125





               FIXIT = 0
               FOR A = 1 TO NUMCOL * 3 STEP 3
                 R = ASC(MID$(PCXPAL, A, 1))
                 G = ASC(MID$(PCXPAL, A + 1, 1))
                 B = ASC(MID$(PCXPAL, A + 2, 1))
                 IF R > 63 THEN
                    FIXIT = 1
                    EXIT FOR
                 END IF
                 IF G > 63 THEN
                    FIXIT = 1
                    EXIT FOR
                 END IF
                 IF B > 63 THEN
                    FIXIT = 1
                    EXIT FOR
                 END IF
               NEXT A
               IF FIXIT = 1 THEN
                 FOR A = 1 TO NUMCOL * 3
                    C = ASC(MID$(PCXPAL, A, 1))
                    MID$(PCXPAL, A, 1) = CHR$(C \ 4)
                 NEXT A
               END IF
               PALSET PCXPAL, 0, 255
               OK = PCXPUT(1, 0, 0, PCXFILENAME$)
               IF OK <> 1 THEN
                 SOUND 100, 5
                 DUMMY = RESTEXT
                 END
               END IF
               WHILE INKEY$ = ""
               WEND
               DUMMY = RESTEXT
            END IF

            END



















                                                                        126





          RES320

            PROTOTYPE

            FUNCTION RES320% ()

            INPUT

            no input parameters

            OUTPUT

            RES320 always returns a 1.

            USAGE

            RES320 sets video mode 0x13 which is the VGA standard 320x200
            graphics mode with 256 colors.  This function can be called
            without calling WHICHVGA first as this function requires only
            that a VGA card is present, not a Super VGA card.  If a VGA is
            not present, the system may crash.

            SEE ALSO

            RES640, RES640L, RES800, RES1024, RES1280, WHICHVGA

            EXAMPLE

            REM SET THE VIDEO MODE TO 320x200x256
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            DUMMY=RES320
            DRWSTRING 1, 7, 0, "THIS IS THE 320x200x256 VIDEO MODE...", 0,
            0
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END















                                                                        127





          RES640

            PROTOTYPE

            FUNCTION RES640% ()

            INPUT

            no input parameters

            OUTPUT

            RES640 returns 1 if successful, 0 otherwise.

            USAGE

            RES640 sets the video mode to 640x480 graphics mode with 256
            colors.  This function requires that a Super VGA card with at
            least 512K of video memory be present.  Also, WHICHVGA must be
            called first or the function will fail without changing the
            video mode.  If the video card does not have sufficient
            memory, RES640 will return without changing the video mode.

            SEE ALSO

            RES320, RES640L, RES800, RES1024, RES1280, WHICHVGA

            EXAMPLE

            REM SET THE VIDEO MODE TO 640x480x256
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            IF WHICHMEM < 512 THEN STOP
            DUMMY=RES640
            DRWSTRING 1, 7, 0, "THIS IS THE 640x480x256 VIDEO MODE...", 0,
            0
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END













                                                                        128





          RES640L

            PROTOTYPE

            FUNCTION RES640L% ()

            INPUT

            no input parameters

            OUTPUT

            RES640L returns 1 if successful, 0 otherwise.

            USAGE

            RES640L sets the video mode to 640x400 graphics mode with 256
            colors.  This function requires that a Super VGA card with at
            least 256K of video memory be present.  Also, WHICHVGA must be
            called first or the function will fail without changing the
            video mode.  If the video card does not have sufficient
            memory, RES640L will return without changing the video mode.

            Note: 640x400 is a non-standard resolution.  Not all SVGA
            cards recognized by this library support this video mode.

            SEE ALSO

            RES320, RES640, RES800, RES1024, RES1280, WHICHVGA

            EXAMPLE

            REM SET THE VIDEO MODE TO 640x400x256
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            IF WHICHMEM < 256 THEN STOP
            DUMMY=RES640L
            DRWSTRING 1, 7, 0, "THIS IS THE 640x400x256 VIDEO MODE...", 0,
            0
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END










                                                                        129





          RES800

            PROTOTYPE

            FUNCTION RES800% ()

            INPUT

            no input parameters

            OUTPUT

            RES800 returns 1 if successful, 0 otherwise.

            USAGE

            RES800 sets the video mode to 800x600 graphics mode with 256
            colors.  This function requires that a Super VGA card with at
            least 512K of video memory be present.  Also, WHICHVGA must be
            called first or the function will fail without changing the
            video mode.  If the video card does not have sufficient
            memory, RES800 will return without changing the video mode.

            SEE ALSO

            RES320, RES640, RES640L, RES1024, RES1280, WHICHVGA

            EXAMPLE

            REM SET THE VIDEO MODE TO 800x600x256
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            IF WHICHMEM < 512 THEN STOP
            DUMMY=RES800
            DRWSTRING 1, 7, 0, "THIS IS THE 800x600x256 VIDEO MODE...", 0,
            0
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END













                                                                        130





          RES1024

            PROTOTYPE

            FUNCTION RES1024% ()

            INPUT

            no input parameters

            OUTPUT

            RES1024 returns 1 if successful, 0 otherwise.

            USAGE

            RES1024 sets the video mode to 1024x768 graphics mode with 256
            colors.  This function requires that a Super VGA card with at
            least 1 Megabyte of video memory be present.  Also, WHICHVGA
            must be called first or the function will fail without
            changing the video mode.  If the video card does not have
            sufficient memory, RES1024 will return without changing the
            video mode.

            SEE ALSO

            RES320, RES640, RES640L, RES800, RES1280, WHICHVGA

            EXAMPLE

            REM SET THE VIDEO MODE TO 1024x768x256
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            IF WHICHMEM < 1024 THEN STOP
            DUMMY=RES1024
            DRWSTRING 1, 7, 0, "THIS IS THE 1024x768x256 VIDEO MODE...",
            0, 0
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END












                                                                        131





          RES1280

            PROTOTYPE

            FUNCTION RES1280% ()

            INPUT

            no input parameters

            OUTPUT

            RES1280 returns 1 if successful, 0 otherwise.

            USAGE

            RES1280 sets the video mode to 1280x1024 graphics mode with
            256 colors.  This function requires that a Super VGA card with
            at least 2 Megabytes of video memory be present.  Also,
            WHICHVGA must be called first or the function will fail
            without changing the video mode.  If the video card does not
            have sufficient memory, RES1280 will return without changing
            the video mode.

            SEE ALSO

            RES320, RES640, RES640L, RES800, RES1024, WHICHVGA

            EXAMPLE

            REM SET THE VIDEO MODE TO 1280x1024x256
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            IF WHICHMEM < 2048 THEN STOP
            DUMMY=RES1024
            DRWSTRING 1, 7, 0, "THIS IS THE 1280x1024x256 VIDEO MODE...",
            0, 0
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END












                                                                        132





          RESTEXT

            PROTOTYPE

            FUNCTION RESTEXT% ()

            INPUT

            no input parameters

            OUTPUT

            RESTEXT always returns a 1.

            USAGE

            RESTEXT sets video mode three which is the VGA standard 80x25
            text mode.

            SEE ALSO

            VIDEOMODEGET, VIDEOMODESET

            EXAMPLE

            REM SET THE VIDEO MODE TO STANDARD DOS TEXT MODE 3
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            RESTEXT
            PRINT "THIS IS THE TEXT VIDEO MODE (DOS VIDEO MODE 3)...
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END




















                                                                        133





          SCROLLDN

            PROTOTYPE

            SUB SCROLLDN (X1%, Y1%, X2%, Y2%, Num%, Color%)

            INPUT

            X1, Y1 - top left corner of block
            X2, Y2 - bottom right corner of block
            Num - number of pixels to shift
            Color - index to color in current palette

            OUTPUT

            no value returned

            USAGE

            SCROLLDN shifts the contents of the box described by (X1, Y1)
            - (X2, Y2) down by the number of pixels specified by Num.  The
            empty pixels created at the top of the box are filled with
            Color.  The pixels that are shifted out of the box are lost.
            SCROLLDN enforces X2 X1 and Y2Y1.  When placed within a loop,
            SCROLLDN will create a scrolling effect.

            SEE ALSO

            SCROLLLT, SCROLLRT, SCROLLUP

            EXAMPLE

            REM SCROLL SOME TEXT DOWN
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            IF WHICHMEM < 512 THEN STOP
            DUMMY=RES640
            DRWBOX 1, 10, 0, 0, 100, 100
            DRWSTRING 1, 7, 0, "TEXT TEXT", 20, 43
            FOR I = 0 TO 40
               SCROLLDN 1, 1, 99, 99, 1, 0
               SDELAY 2
            NEXT I
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END






                                                                        134





          SCROLLLT

            PROTOTYPE

            SUB SCROLLLT (X1%, Y1%, X2%, Y2%, Num%, Color%)

            INPUT

            X1, Y1 - top left corner of block
            X2, Y2 - bottom right corner of block
            Num - number of pixels to shift
            Color - index to color in current palette

            OUTPUT

            no value returned

            USAGE

            SCROLLLT shifts the contents of the box described by (X1, Y1)
            - (X2, Y2) down by the number of pixels specified by Num.  The
            empty pixels created at the right of the box are filled with
            Color.  The pixels that are shifted out of the box are lost.
            SCROLLLT enforces X2 X1 and Y2Y1.  When placed within a loop,
            SCROLLRT will create a scrolling effect.

            SEE ALSO

            SCROLLDN, SCROLLRT, SCROLLUP

            EXAMPLE

            REM SCROLL SOME TEXT LEFT
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            IF WHICHMEM < 512 THEN STOP
            DUMMY=RES640
            DRWBOX 1, 10, 0, 0, 100, 100
            DRWSTRING 1, 7, 0, "TEXT TEXT", 20, 43
            FOR I = 0 TO 40
               SCROLLLT 1, 1, 99, 99, 1, 0
               SDELAY 2
            NEXT I
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END






                                                                        135





          SCROLLRT

            PROTOTYPE

            SUB SCROLLRT (X1%, Y1%, X2%, Y2%, Num%, Color%)

            INPUT

            X1, Y1 - top left corner of block
            X2, Y2 - bottom right corner of block
            Num - number of pixels to shift
            Color - index to color in current palette

            OUTPUT

            no value returned

            USAGE

            SCROLLRT shifts the contents of the box described by (X1, Y1)
            - (X2, Y2) down by the number of pixels specified by Num.  The
            empty pixels created at the left of the box are filled with
            Color.  The pixels that are shifted out of the box are lost.
            SCROLLRT enforces X2 X1 and Y2Y1.  When placed within a loop,
            SCROLLRT will create a scrolling effect.

            SEE ALSO

            SCROLLDN, SCROLLLT, SCROLLUP

            EXAMPLE

            REM SCROLL SOME TEXT RIGHT
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            IF WHICHMEM < 512 THEN STOP
            DUMMY=RES640
            DRWBOX 1, 10, 0, 0, 100, 100
            DRWSTRING 1, 7, 0, "TEXT TEXT", 20, 43
            FOR I = 0 TO 40
               SCROLLRT 1, 1, 99, 99, 1, 0
               SDELAY 2
            NEXT I
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END






                                                                        136





          SCROLLUP

            PROTOTYPE

            SUB SCROLLUP (X1%, Y1%, X2%, Y2%, Num%, Color%)

            INPUT

            X1, Y1 - top left corner of block
            X2, Y2 - bottom right corner of block
            Num - number of pixels to shift
            Color - index to color in current palette

            OUTPUT

            no value returned

            USAGE

            SCROLLUP shifts the contents of the box described by (X1, Y1)
            - (X2, Y2) down by the number of pixels specified by Num.  The
            empty pixels created at the bottom of the box are filled with
            Color.  The pixels that are shifted out of the box are lost.
            SCROLLUP enforces X2 X1 and Y2Y1.  When placed within a loop,
            SCROLLUP will create a scrolling effect.

            SEE ALSO

            SCROLLDN, SCROLLLT, SCROLLRT

            EXAMPLE

            REM SCROLL SOME TEXT UP
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            IF WHICHMEM < 512 THEN STOP
            DUMMY=RES640
            DRWBOX 1, 10, 0, 0, 100, 100
            DRWSTRING 1, 7, 0, "TEXT TEXT", 20, 43
            FOR I = 0 TO 40
               SCROLLUP 1, 1, 99, 99, 1, 0
               SDELAY 2
            NEXT I
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END






                                                                        137





          SDELAY

            PROTOTYPE

            SUB SDELAY (Count%)

            INPUT

            Count - number of vertical syncs to wait

            OUTPUT

            no value returned

            USAGE

            SDELAY pauses execution of the program for a period of time
            specified by Count.  This delay remains approximately constant
            on all machines by using the vertical sync timer of the VGA
            graphics card which is about 60 - 70 Hz.

            EXAMPLE

            REM MAKE A DELAY ABOUT 3 SECONDS LONG
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            CLS
            PRINT "OK...STARTING DELAY NOW..."
            PRINT "SHOULD BE ABOUT 3 SECONDS..."
            PRINT
            TIM! = TIMER
            SDELAY 195
            TOT! = TIMER - TIM!
            PRINT "ACTUAL TIME WAS:"; TOT!
            WHILE INKEY$ = ""
            WEND
            END


















                                                                        138





          SETCARD

            PROTOTYPE

            SUB SETCARD (Chip%, Mem%)

            INPUT

            Chip - code for certain SVGA chip type
            Mem - amount of video memory installed

            OUTPUT

            no value returned

            USAGE

            WARNING:  USING SETCARD IMPROPERLY MAY CAUSE A SYSTEM FAILURE
            OR DAMAGE.
            SETCARD sets the card type and installed video memory.  It can
            be used instead of the WHICHVGA function.  However, specifying
            an incorrect chip type or installed video memory may cause
            unpredictable results not excluding damage to the SVGA card
            and/or monitor.  Extreme caution is advised when using this
            function.  It is recommended that this function only be used
            when it is suspected that the identification process in
            WHICHVGA failed.  Be absolutely certain that the chip type
            specified is the actual chip type installed in the computer.
            Mem should be a value of 256, 512, 1024  or 2048 representing
            the kilobytes of video memory installed.  Use the following
            table to identify chip types:

          1  Acumos AVGA2/3 SuperVGA
          2  ATI Technologies 18/28/38/68800
             SuperVGA
          3  Ahead V5000 ver A SuperVGA
          4  Ahead V5000 ver B SuperVGA
          5  Chips and Technologies 82C45x SuperVGA
          6  Cirrus Logic CL-GD 5xx, 6xx, 28xx,
             54xx, 62xx SuperVGA
          7  Everex Micro Enhancer Ev236/6xx
             SuperVGA
          8  Genoa 61/62/63/64/6600 SuperVGA
          9  NCR 77C21/22/22E/22E+ SuperVGA
          10 Oak Technologies OTI-037C/067/077/087
             SuperVGA
          11 Paradise/Western Digital PVGA1A,
             WD90C00/1x/2x/3x SuperVGA
          12 Realtek RT3106 SuperVGA
          13 Trident 8800CS, 8900B/C/CL/CX, 90x0
             SuperVGA
          14 Tseng Labs ET3000-AX/BX/BP SuperVGA
          15 Tseng Labs ET4000/W32/W32I SuperVGA
          16 VESA compatible SuperVGA


                                                                        139





          17 Video 7 HT-208/16 SuperVGA
          18 Avance Logic AL2101 SuperVGA
          19 MXIC MX68000/10 SuperVGA
          20 Primus P2000 SuperVGA

            SEE ALSO

            WHICHVGA

            EXAMPLE

            REM
            !WARNING!WARNING!WARNING!WARNING!WARNING!WARNING!WARNING!WARNI
            NG!

            REM USE THIS FUNCTION CAREFULLY. IT WORKS AROUND THE "WHICHVGA
            FUNCTION"
            REM IMPROPER USE (I.E. SETTING THE CARD ID AND MEMORY TO
            SOMETHING THAT
            REM THAT IS NOT VALID) MIGHT DAMAGE YOUR VIDEO CARD/VIDEO
            MONITOR OR
            REM CAUSE UNPREDICTABLE RESULTS. IT IS PROVIDED AS A METHOD TO
            FIND
            REM FAULTS IN THE VIDEO CARD/CHIP ID PROCESS.

            REM
            !WARNING!WARNING!WARNING!WARNING!WARNING!WARNING!WARNING!WARNI
            NG!

            END


























                                                                        140





          SETVIEW

            PROTOTYPE

            SUB SETVIEW (X1%, Y1%, X2%, Y2%)

            INPUT

            X1, Y1 - top, left corner of view port
            X2, Y2 - bottom, right corner of view port

            OUTPUT

            no value returned

            USAGE

            SETVIEW defines a viewport for clipping output on the screen.
            Nothing can be drawn outside of the currently defined
            viewport.  The RES### functions set the viewport to the full
            screen.  The restrictions on X1, Y1, X2 and Y2 are as follows:

            0   X1 < X2  (screen width)
            0   Y1 < Y2  (32767, effectively unbounded)

            SEE ALSO

            RES320, RES640, RES640L, RES800, RES1024, RES1280

            EXAMPLE

            REM DRAW SOME LINES CLIPPED TO A VIEWPORT
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            IF WHICHMEM < 512 THEN STOP
            DUMMY=RES640
            DRWBOX 1, 15, 100, 100, 539, 379
            SETVIEW 101, 101, 538, 378
            FOR I = 0 TO 300
               X1 = RND * 640
               Y1 = RND * 480
               X2 = RND * 640
               Y2 = RND * 480
               DRWLINE 1, 10, X1, Y1, X2, Y2
            NEXT I
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END




                                                                        141





          SPRITECOLLDETECT

            PROTOTYPE

            FUNCTION SPRITECOLLDETECT% (TransColor%, X1%, Y1%, X2%, Y2%,
            GfxBlk1%, GfxBlk2%)

            INPUT

            TransColor - index to color in current palette
            X1, Y1 - top, left corner of sprite number 1
            X2, Y2 - top, left corner of sprite number 2
            GfxBlk1 - predefined integer array containing the sprite
            number 1
            GfxBlk2 - predefined integer array containing the sprite
            number 2

            OUTPUT

            SPRITECOLLDETECT returns the collision status of the two
            sprites.

            USAGE

            SPRITECOLLDETECT is used in sprite graphics or animation to
            report the collision status between two sprites.  GfxBlk1, a
            short integer array, contains the first sprite which should
            have been previously defined by BLKGET or similar function.
            GfxBlk2, likewise, contains the second sprite.  The top, left
            corner of the first and second sprites' locations are
            specified by X1, Y1 and X2, Y2, respectively.

            SPRITECOLLDETECT will return a zero if the sprites are not
            colliding and the blocks are not overlapping.  The return will
            be one if the blocks overlap, but the sprites are not
            colliding.  A return value of two indicates that the sprites
            have at least one overlapping pixel and are, therefore,
            colliding.

            Arrays should be passed by giving the element within the array
            from where the action should take place.  This allows the
            programmer to store more than one item within the same array
            or act on only a portion of the array.

            SEE ALSO

            BLKGET, BLKPUT, GETLASTSTRING, SPRITEGAP, SPRITEGET, SPRITEPUT

            EXAMPLE

            REM SHOW THE RESULTS OF THE SPRITE COLLISION DETECTION
            FUNCTION
            REM $INCLUDE: 'SVGABC.BI'



                                                                        142





            DEFINT A-Z

            DIM D1(0 TO 4000) AS INTEGER
            DIM D2(0 TO 4000) AS INTEGER

            IF WHICHVGA < 0 THEN STOP
            ORGMODE = VIDEOMODEGET
            DUMMY=RES320
            X1 = 0
            Y1 = 0
            X2 = 24
            Y2 = 24
            DRWLINE 1, 8, X1, Y1, X2, Y1
            DRWLINE 1, 8, X2, Y1, X2, Y2
            DRWLINE 1, 8, X2, Y2, X1, Y2
            DRWLINE 1, 8, X1, Y2, X1, Y1
            FILLAREA X1 + 1, Y1 + 1, 8, 8
            DRWLINE 1, 10, X1, Y1, X2, Y2
            DRWLINE 1, 10, X2, Y1, X1, Y2
            BLKGET X1, Y1, X2, Y2, D1(0)
            BLKPUT 2, X1, Y1, D1(0)
            X1 = 0
            Y1 = 0
            X2 = 48
            Y2 = 48
            DRWLINE 1, 8, X1, Y1, X2, Y1
            DRWLINE 1, 8, X2, Y1, X2, Y2
            DRWLINE 1, 8, X2, Y2, X1, Y2
            DRWLINE 1, 8, X1, Y2, X1, Y1
            FILLAREA X1 + 1, Y1 + 1, 8, 8
            DRWCIRCLE 1, 10, X1 + 24, Y1 + 24, 24
            BLKGET X1, Y1, X2, Y2, D2(0)
            BLKPUT 2, X1, Y1, D2(0)
            X1 = 90
            Y1 = 90
            BLKPUT 2, X1, Y1, D2(0)
            FOR X = 50 TO 150
               BLKPUT 2, X, X, D1(0)
               A = SPRITECOLLDETECT(8, X, X, X1, Y1, D1(0), D2(0))
               A$ = STR$(A)
               IF LEN(A$) < 5 THEN A$ = A$ + " "
               DRWSTRING 1, 7, 0, A$, 0, 0
               WHILE INKEY$ = ""
               WEND
               BLKPUT 2, X, X, D1(0)
            NEXT X
            VIDEOMODESET ORGMODE
            END








                                                                        143





          SPRITEGAP

            PROTOTYPE

            SUB SPRITEGAP (TransColor%, X%, Y%, GfxBlk%, BkGndGfxBlk%)

            INPUT

            TransColor - index to color in current palette
            X, Y - top, left corner of block
            GfxBlk - predefined integer array containing the sprite

            OUTPUT

            no value returned
            BkGndGfxBlk - integer array holding the sprite background

            USAGE

            SPRITEGAP ("Sprite-Get-And-Put") is used in sprite graphics or
            animation to retrieve a sprite's background and then display
            the sprite.  GfxBlk, a short integer array, contains the
            sprite which should have been previously defined by BLKGET or
            similar function such as GETLASTSTRING.  TransColor is the
            transparent color assumed in GfxBlk.  BkGndGfxBlk, an empty
            short integer array the same size as GfxBlk, will receive the
            sprite's background.  The top, left corner of the sprite's
            location is specified by X, Y.

            Arrays should be passed by giving the element within the array
            from where the action should take place.  This allows the
            programmer to store more than one item within the same array
            or act on only a portion of the array.

            SEE ALSO

            BLKGET, BLKPUT, GETLASTSTRING, SPRITECOLLDETECT, SPRITEGET,
            SPRITEPUT

            EXAMPLE

            REM SHOW SPRITEGAP
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z
            DIM GFXBLK1(10000)
            DIM GFXBLK2(10000)
            DIM GFXBLK3(10000)

            IF WHICHVGA = 0 THEN STOP
            VMODE = VIDEOMODEGET
            IF RES640 <> 1 THEN
               VIDEOMODESET VMODE
               END
            END IF


                                                                        144





            Colr = 1
            FOR I = 0 TO GETMAXX \ 2
               DRWCIRCLE 1, Colr, GETMAXX \ 4 + I, GETMAXY \ 2, GETMAXY \ 5
               Colr = Colr + 1
               IF Colr > 15 THEN
                 Colr = 1
               END IF
            NEXT I
            XINC = GETMAXX \ 20
            YINC = GETMAXY \ 20
            X1 = GETMAXX \ 2 - XINC
            Y1 = GETMAXY \ 2 - YINC
            X2 = GETMAXX \ 2 + XINC
            Y2 = GETMAXY \ 2 + YINC
            X = (X2 - X1) \ 2 + X1
            Y = (Y2 - Y1) \ 2 + Y1
            BLKGET X1, Y1, X2, Y2, GFXBLK1(0)
            DRWBOX 1, 0, X1, Y1, X2, Y2
            FILLAREA X1 + 2, Y1 + 2, 0, 0
            BLKGET X1, Y1, X2, Y2, GFXBLK3(0)
            FOR I = 0 TO 360 STEP 3
               DUMMY = BLKROTATE(I, 1, GFXBLK1(0), GFXBLK2(0))
               SPRITEPUT 1, 1, X - GFXBLK3(0) \ 2, Y - GFXBLK3(1) \ 2,
            GFXBLK3(0)
               SPRITEGAP 1, X - GFXBLK2(0) \ 2, Y - GFXBLK2(1) \ 2,
            GFXBLK2(0), GFXBLK3(0)
               SDELAY 3
            NEXT I
            SPRITEPUT 1, 1, X - GFXBLK3(0) \ 2, Y - GFXBLK3(1) \ 2,
            GFXBLK3(0)
            BLKPUT 1, X1, Y1, GFXBLK1(0)
            VIDEOMODESET VMODE
            END























                                                                        145





          SPRITEGET

            PROTOTYPE

            SUB SPRITEGET (TransColor%, X%, Y%, GfxBlk%, BkGndGfxBlk%)

            INPUT

            TransColor - index to color in current palette
            X, Y - top, left corner of block
            GfxBlk - predefined integer array containing the sprite

            OUTPUT

            no value returned
            BkGndGfxBlk - integer array holding the sprite background

            USAGE

            SPRITEGET is used in sprite graphics or animation to retrieve
            the background for a sprite, normally just before using
            SPRITEPUT.  GfxBlk, a short integer array, contains the sprite
            which should have been previously defined by BLKGET or similar
            function.  TransColor is the transparent color assumed in
            GfxBlk.  BkGndGfxBlk, an empty short integer array of the same
            size as GfxBlk, will receive the sprite's background.  The
            top, left corner of the sprite's location is specified by X,
            Y.

            Arrays should be passed by giving the element within the array
            from where the action should take place.  This allows the
            programmer to store more than one item within the same array
            or act on only a portion of the array.

            SEE ALSO

            BLKGET, BLKPUT, GETLASTSTRING, SPRITECOLLDETECT, SPRITEGAP,
            SPRITEPUT

            EXAMPLE

            REM SHOW SPRITEGET
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z
            DIM GFXBLK1(10000)
            DIM GFXBLK2(10000)
            DIM GFXBLK3(10000)

            IF WHICHVGA = 0 THEN STOP
            VMODE = VIDEOMODEGET
            IF RES640 <> 1 THEN
               VIDEOMODESET VMODE
               END
            END IF


                                                                        146





            Colr = 1
            FOR I = 0 TO GETMAXX \ 2
               DRWCIRCLE 1, Colr, GETMAXX \ 4 + I, GETMAXY \ 2, GETMAXY \ 5
               Colr = Colr + 1
               IF Colr > 15 THEN
                 Colr = 1
               END IF
            NEXT I
            XINC = GETMAXX \ 20
            YINC = GETMAXY \ 20
            X1 = GETMAXX \ 2 - XINC
            Y1 = GETMAXY \ 2 - YINC
            X2 = GETMAXX \ 2 + XINC
            Y2 = GETMAXY \ 2 + YINC
            X = (X2 - X1) \ 2 + X1
            Y = (Y2 - Y1) \ 2 + Y1
            BLKGET X1, Y1, X2, Y2, GFXBLK1(0)
            DRWBOX 1, 0, X1, Y1, X2, Y2
            FILLAREA X1 + 2, Y1 + 2, 0, 0
            BLKGET X1, Y1, X2, Y2, GFXBLK3(0)
            FOR I = 0 TO 360 STEP 3
               DUMMY = BLKROTATE(I, 1, GFXBLK1(0), GFXBLK2(0))
               SPRITEPUT 1, 1, X - GFXBLK3(0) \ 2, Y - GFXBLK3(1) \ 2,
            GFXBLK3(0)
               SPRITEGET 1, X - GFXBLK2(0) \ 2, Y - GFXBLK2(1) \ 2,
            GFXBLK2(0), GFXBLK3(0)
               SPRITEPUT 1, 1, X - GFXBLK2(0) \ 2, Y - GFXBLK2(1) \ 2,
            GFXBLK2(0)
               SDELAY 3
            NEXT I
            SPRITEPUT 1, 1, X - GFXBLK3(0) \ 2, Y - GFXBLK3(1) \ 2,
            GFXBLK3(0)
            BLKPUT 1, X1, Y1, GFXBLK1(0)
            VIDEOMODESET VMODE
            END





















                                                                        147





          SPRITEPUT

            PROTOTYPE

            SUB SPRITEPUT (Mode%, TransColor%, X%, Y%, GfxBlk%)

            INPUT

            Mode - pixel write mode (SET=1, XOR=2, OR=3, AND=4)
            TransColor - index to color in current palette
            X, Y - top, left corner of block
            GfxBlk - predefined integer array containing the sprite

            OUTPUT

            no value returned

            USAGE

            SPRITEPUT is used in sprite graphics or animation to display a
            sprite or, more commonly, its background.  GfxBlk, a short
            integer array, contains the sprite which should have been
            previously defined by BLKGET,  SPRITEGAP or SPRITEGET.
            TransColor is the transparent color assumed in GfxBlk.  The
            top, left corner of the sprite's location is specified by X,
            Y.

            Arrays should be passed by giving the element within the array
            from where the action should take place.  This allows the
            programmer to store more than one item within the same array
            or act on only a portion of the array.

            SEE ALSO

            BLKGET, BLKPUT, GETLASTSTRING, SPRITECOLLDETECT, SPRITEGAP,
            SPRITEGET

            EXAMPLE

            See SPRITEGAP
















                                                                        148





          VIDEOMODEGET

            PROTOTYPE

            FUNCTION VIDEOMODEGET% ()

            INPUT

            no input parameters

            OUTPUT

            VIDEOMODEGET returns the current video mode.

            USAGE

            VIDEOMODEGET returns the current video mode.  This function is
            best used to retrieve the video mode being used when a program
            begins.  When the program ends, this video mode can then be
            restored using VIDEOMODESET.

            SEE ALSO

            RES320, RES640, RES640L, RES800, RES1024, RES1280, RESTEXT,
            VIDEOMODESET

            EXAMPLE

            REM SAVE THE VIDEO MODE,SWITCH TO 640X480X256, RESTORE THE
            ORIGINAL MODE
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            VMODE = VIDEOMODEGET
            IF WHICHVGA = 0 THEN STOP
            IF WHICHMEM < 512 THEN STOP
            DUMMY=RES640
            DRWSTRING 1, 7, 0, "PRESS A KEY...", 0, 0
            WHILE INKEY$ = ""
            WEND
            VIDEOMODESET VMODE
            END














                                                                        149





          VIDEOMODESET

            PROTOTYPE

            SUB VIDEOMODESET (Mode%)

            INPUT

            Mode - number of video mode

            OUTPUT

            no value returned

            USAGE

            VIDEOMODESET sets the video mode specified by Mode.  This
            function is best used at the end of a program to restore the
            video mode to the mode in use when the program began.  The
            program should retrieve the video mode at the beginning by
            using VIDEOMODEGET.

            SEE ALSO

            RES320, RES640, RES640L, RES800, RES1024, RES1280, RESTEXT,
            VIDEOMODEGET

            EXAMPLE

            See VIDEOMODEGET


























                                                                        150





          VIDEOOFF

            PROTOTYPE

            SUB VIDEOOFF ()

            INPUT

            no input parameters

            OUTPUT

            no value returned

            USAGE

            VIDEOOFF turns the output display off.  Graphics may still be
            drawn to the screen.  However, the computer's monitor will
            display nothing and appear black.  This function can be used
            to hide graphics being drawn by initially using VIDEOOFF and
            then later calling VIDEOON.

            SEE ALSO

            VIDEOON

            EXAMPLE

            REM DISABLE THE VIDEO FOR ABOUT 3 SEC
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            CLS
            PRINT "PRESS A KEY TO DISABLE THE VIDEO DISPLAY FOR 3 SECONDS"
            WHILE INKEY$ = ""
            WEND
            VIDEOOFF
            SDELAY 195
            VIDEOON
            PRINT "OK...WE ARE BACK!"
            WHILE INKEY$ = ""
            WEND
            END













                                                                        151





          VIDEOON

            PROTOTYPE

            SUB VIDEOON ()

            INPUT

            no input parameters

            OUTPUT

            no value returned

            USAGE

            VIDEOON turns the display back on.  All graphics that were
            drawn while the display was off are now visible.  This
            function can be used to hide graphics being drawn by initially
            using VIDEOOFF and then later calling VIDEOON.

            SEE ALSO

            VIDEOOFF

            EXAMPLE

            See VIDEOOFF




























                                                                        152





          WHICHCPU

            PROTOTYPE

            FUNCTION WHICHCPU% ()

            INPUT

            no input parameters

            OUTPUT

            WHICHCPU returns the processor type.

            USAGE

            WHICHCPU returns the computer's processor type as 86, 286,
            386, 486 or 586.  This function should be called by any
            program using this library's routines to insure that the
            computer is at least 386 compatible or better.

            SEE ALSO

            WHICHJOYSTICK, WHICHMOUSE, WHICHVGA

            EXAMPLE

            REM FIND OUT WHAT KIND OF MICROPROCESSOR WE HAVE
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            CLS
            CPU = WHICHCPU
            CPU$ = STR$(CPU)
            L = LEN(CPU$)
            CPU$ = RIGHT$(CPU$, L - 1)
            PRINT "Microprocessor is identified as a 80"; CPU$; "."
            END


















                                                                        153





          WHICHJOYSTICK

            PROTOTYPE

            FUNCTION WHICHJOYSTICK% ()

            INPUT

            no input parameters

            OUTPUT

            WHICHJOYSTICK returns the available joystick support.

            USAGE

            WHICHJOYSTICK returns the joystick support available on the
            computer.  This function should be called prior to use of the
            joysticks to verify that joysticks are available.  If the
            function returns a -1, there is no joystick port present or no
            BIOS support for a joystick.  Joystick A is bit 1 and B is bit
            2.  Therefore, a return value of 1 means joystick A is
            available, a value of 2 means B is available and a value of 3
            means both are available.  If no bits are set, there are no
            joysticks present.

            SEE ALSO

            JOYSTICKINFO, WHICHCPU, WHICHMOUSE, WHICHVGA

            EXAMPLE

            REM FIND OUT IF WE HAVE ANY JOYSTICKS AVAILABLE
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            CLS
            JOYSTICK = WHICHJOYSTICK
            SELECT CASE JOYSTICK
               CASE IS = -1
                 A$ = "No joystick port detected or no joystick BIOS
            support present."
               CASE IS = 0
                 A$ = "No joystick detected."
               CASE IS = 1
                 A$ = "Joystick A is present and available."
               CASE IS = 2
                 A$ = "Joystick B is present and available."
               CASE IS = 3
                 A$ = "Both Joystick A and Joystick B are present and
            available."
            END SELECT
            PRINT A$
            END


                                                                        154





          WHICHMEM

            PROTOTYPE

            FUNCTION WHICHMEM% ()

            INPUT

            no input parameters

            OUTPUT

            WHICHMEM returns the installed video memory in kilobytes.

            USAGE

            WHICHMEM returns the amount of installed video memory as
            previously determined by WHICHVGA.  WHICHVGA should be called
            prior to WHICHMEM.  This function should be called prior to
            any of the RES### functions to verify that there is enough
            memory to support the resolution.  If SETCARD was used to set
            the video card and memory, WHICHMEM will return the amount of
            memory as defined by SETCARD.

            SEE ALSO

            RES320, RES640, RES640L, RES800, RES1024, RES1280, SETCARD,
            WHICHVGA

            EXAMPLE

            REM FIND OUT HOW MUCH VIDEO MEMORY WE HAVE
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            CLS
            DUMMY = WHICHVGA
            PRINT "INSTALLED VIDEO MEMORY IS IDENTIFIED AS"; WHICHMEM; "k
            BYTES"
            END
















                                                                        155





          WHICHMOUSE

            PROTOTYPE

            FUNCTION WHICHMOUSE% ()

            INPUT

            no input parameters

            OUTPUT

            WHICHMOUSE returns the number of buttons on mouse.

            USAGE

            WHICHMOUSE returns a value indicating whether a Microsoft
            compatible mouse is available.  If the function returns 0, no
            mouse is available.  A non zero value indicates a mouse and
            Microsoft compatible driver are installed and gives the number
            of buttons available.

            SEE ALSO

            MOUSEINFO, WHICHCPU, WHICHJOYSTICK, WHICHVGA

            EXAMPLE

            REM FIND OUT WHAT KIND OF MOUSE WE HAVE
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            CLS
            MOUSE = WHICHMOUSE
            IF MOUSE > 0 THEN
               MOUSEINFO MJV, MNV, TP, I
               VER$ = STR$(MNV)
               L = LEN(VER$)
               VER$ = STR$(MJV) + "." + RIGHT$(VER$, L - 1)
               VER$ = "Software driver version is" + VER$
               VER$ = VER$ + " (Microsoft equivalent version)."
               A$ = "Microsoft compatible mouse detected with"
               A$ = A$ + STR$(MOUSE) + " buttons on IRQ" + STR$(I) + "."
               PRINT A$
               PRINT VER$
            ELSE
               PRINT "No Microsoft compatible mouse detected."
            END IF
            END







                                                                        156





          WHICHVGA

            PROTOTYPE

            FUNCTION WHICHVGA% ()

            INPUT

            no input parameters

            OUTPUT

            WHICHVGA returns a code identifying the video card.

            USAGE

            WHICHVGA identifies the video card installed and the amount of
            video memory.  In addition this function sets up the default
            font and mouse cursor.  This function must be called before
            any other graphics function.  The code returned identifies the
            video card according to the following table:

          1  Acumos AVGA2/3 SuperVGA
          2  ATI Technologies 18/28/38/68800
             SuperVGA
          3  Ahead V5000 ver A SuperVGA
          4  Ahead V5000 ver B SuperVGA
          5  Chips and Technologies 82C45x SuperVGA
          6  Cirrus Logic CL-GD 5xx, 6xx, 28xx,
             54xx, 62xx SuperVGA
          7  Everex Micro Enhancer Ev236/6xx
             SuperVGA
          8  Genoa 61/62/63/64/6600 SuperVGA
          9  NCR 77C21/22/22E/22E+ SuperVGA
          10 Oak Technologies OTI-037C/067/077/087
             SuperVGA
          11 Paradise/Western Digital PVGA1A,
             WD90C00/1x/2x/3x SuperVGA
          12 Realtek RT3106 SuperVGA
          13 Trident 8800CS, 8900B/C/CL/CX, 90x0
             SuperVGA
          14 Tseng Labs ET3000-AX/BX/BP SuperVGA
          15 Tseng Labs ET4000/W32/W32I SuperVGA
          16 VESA compatible SuperVGA
          17 Video 7 HT-208/16 SuperVGA
          18 Avance Logic AL2101 SuperVGA
          19 MXIC MX68000/10 SuperVGA
          20 Primus P2000 SuperVGA

            Any value returned not found on this table represents an
            unidentified video card.

            No graphics functions should be called unless the video card
            is properly identified.


                                                                        157






            SEE ALSO

            SETCARD, WHICHCPU, WHICHJOYSTICK, WHICHMOUSE, WHICHMEM

            EXAMPLE

            REM FIND OUT WHAT KIND OF VIDEO CARD WE HAVE
            DEFINT A-Z

            CLS
            VGA = WHICHVGA
            SELECT CASE VGA
                 CASE IS = 1
                    VGA$ = "Acumos AVGA2/3 SuperVGA"
                 CASE IS = 2
                    VGA$ = "ATI Technologies 18/28/38/68800 SuperVGA"
                 CASE IS = 3
                      VGA$ = "Ahead V5000 ver A SuperVGA"
                 CASE IS = 4
                    VGA$ = "Ahead V5000 ver B SuperVGA"
                 CASE IS = 5
                    VGA$ = "Chips and Technologies 82C450/1/2/3/5/6/7
          SuperVGA"
                 CASE IS = 6
                    VGA$ = "Cirrus Logic CL-GD 5xx,6xx,28xx,54xx,62xx
          SuperVGA"
                 CASE IS = 7
                    VGA$ = "Everex Ev236/6xx Micro Enhancer SuperVGA"
                 CASE IS = 8
                    VGA$ = "Genoa 61/62/63/64/6600 SuperVGA"
                 CASE IS = 9
                    VGA$ = "NCR 77C21/22/22E/22E+ SuperVGA"
                 CASE IS = 10
                    VGA$ = "Oak Technologies OTI-037C/067/077/087 SuperVGA"
                 CASE IS = 11
                    VGA$ = "Paradise/Western Digital
          PVGA1A,WD90C00/1x/2x/3x SuperVGA"
                 CASE IS = 12
                    VGA$ = "Realtek RT3106 SuperVGA"
                 CASE IS = 13
                    VGA$ = "Trident 8800CS,8900B/C/CL/CX,90x0 SuperVGA"
                 CASE IS = 14
                    VGA$ = "Tseng Labs ET3000-AX/BX/BP SuperVGA"
                 CASE IS = 15
                    VGA$ = "Tseng Labs ET4000/W32/W32I SuperVGA"
                 CASE IS = 16
                    VGA$ = "VESA compatible SuperVGA"
                 CASE IS = 17
                    VGA$ = "Video 7 HT-208/16 SuperVGA"
                 CASE IS = 18
                    VGA$ = "Avance Logic AL2101 SuperVGA"
                 CASE IS = 19
                    VGA$ = "MXIC MX68000/10 SuperVGA"


                                                                        158





                 CASE IS = 20
                    VGA$ = "Primus P2000 SuperVGA"
                 CASE ELSE
                    VGA$ = "Unknown"
                    VGA = 0
            END SELECT
            PRINT "Video card/chip is identified as a "; VGA$; "."
            END
















































                                                                        159





          WHICHXMS

            PROTOTYPE

            FUNCTION WHICHXMS% (XmsKBytesAvailable%, XmsHandlesAvailable%)

            INPUT

            no input parameters

            OUTPUT

            WHICHXMS returns a 1 if extended memory support is detected, 0
            otherwise.
            XmsKBytesAvailable - number of free kilobytes in extended
            memory
            XmsHandlesAvailable - number of available free handles

            USAGE

            WHICHXMS detects the existence of extended memory support and
            sets up the library function calls.  This function must be
            called before any other extended memory functions.  WHICHXMS
            also returns the number of free kilobytes of extended memory
            and the number of available handles.  The number of available
            handles is limited, normally to 32.  This limit can be
            modified by changing the extended memory driver (Microsoft's
            HIMEM.SYS is the most common) command line in the CONFIG.SYS
            file.

            SEE ALSO

            XMSALLOCATE, XMSCOPY, XMSERROR, XMSFREE, XMSGET, XMSPUT

            EXAMPLE

            REM THIS WILL SHOW IF XMS MEMORY IS AVAILABLE AND HOW MUCH
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z
            IF WHICHXMS(MEM, HANDLES) = 1 THEN
               PRINT "AN XMS MEMORY MANAGER IS INSTALLED (SUCH AS
            'HIMEM.SYS')"
               IF MEM > 0 THEN
                 TOTMEM& = 1024
                 TOTMEM& = TOTMEM& * MEM
                 PRINT "A TOTAL OF"; TOTMEM&; "BYTES ARE AVAILABLE"
                 IF HANDLES > 0 THEN
                    PRINT "A TOTAL OF"; HANDLES; "HANDLES(S) ARE AVAILABLE"
                    PRINT "XMS MEMORY IS READY FOR USE"
                 ELSE
                    PRINT "SORRY...ALL XMS HANDLES ARE BEING USED"
                    PRINT "CHANGE (OR ADD) THE '/numhandles' SWITCH ON YOUR
            XMS MEMORY MANAGER"
                 END IF


                                                                        160





               ELSE
                 PRINT "SORRY...ALL XMS MEMORY IS ALLOCATED"
               END IF
            ELSE
               PRINT "SORRY...NO ACTIVE XMS MEMORY MANAGER FOUND"
               PRINT "MAKE SURE YOU HAVE AN XMS MEMORY MANAGER (SUCH AS
            'HIMEM.SYS' INSTALLED)"
            END IF
            END















































                                                                        161





          XMSALLOCATE

            PROTOTYPE

            FUNCTION XMSALLOCATE% (RequestedKBytes%)

            INPUT

            RequestedKBytes - requested number of kilobytes of extended
            memory

            OUTPUT

            XMSALLOCATE returns the assigned memory handle if the
            allocation is successful, 0 otherwise.

            USAGE

            XMSALLOCATE attempts to allocate the requested number of
            kilobytes in extended memory.  If successful, the function
            returns the handle of the new memory block.  If the function
            returns zero, then the allocation was unsuccessful; check
            XMSERROR for error codes.

            All allocated blocks must be freed using XMSFREE before a
            program terminates or the memory is lost until the machine is
            rebooted.  Simply exiting a program will not free allocated
            extended memory blocks.

            SEE ALSO

            WHICHXMS, XMSCOPY, XMSERROR, XMSFREE, XMSGET, XMSPUT

            EXAMPLE

            See XMSCOPY




















                                                                        162





          XMSBLKGET

            PROTOTYPE

            FUNCTION XMSBLKGET (X1%, Y1%, X2%, Y2%)

            INPUT

            X1, Y1 - top left corner of block
            X2, Y2 - bottom right corner of block

            OUTPUT

            Used as a function, XMSBLKGET returns the assigned XMS memory
            handle if successful, 0 if it otherwise.

            USAGE

            XMSBLKGET stores the pixel data contained within the block
            defined by (X1, Y1)-(X2, Y2) in extended memory.  A minimum of
            32k of XMS memory will be allocated regardless of the size of
            the graphics block.  Note that XMSBLKGET enforces X2>X1 and
            Y2>Y1.  Also, the coordinates must be valid on the screen at
            the current resolution.  The bitmap is stored such that the
            first integer in the allocated XMS block is the width and the
            second integer is the height.  These are followed by a long
            integer (4 bytes) that specifies the total size of the
            allocated XMS block.  The remaining bytes are the bitmap
            raster data stored by rows starting at the top of the block.
            If the function was unsuccessful, check XMSERROR for error
            codes.

            All allocated XMS blocks must be freed using XMSFREE before a
            program terminates or the memory is lost until the machine is
            rebooted.  Simply exiting a program will not free allocated
            extended memory blocks.

            SEE ALSO

            XMSBLKPUT, XMSERROR, XMSFREE, XMSSCREENGET, XMSSCREENPUT,

            EXAMPLE

            REM THIS WILL COPY A LARGE GRAPHICS BLOCK (ABOUT 80K)
            REM FROM ONE PART OF THE SCRREN TO ANOTHER
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            CLS
            IF WHICHXMS(MEM, HANDLES) = 1 THEN
               IF MEM < 1 OR HANDLES < 1 THEN
                 PRINT "SORRY...THERE IS EITHER NO FREE XMS MEMORY OR NO
            FREE XMS HANDLES"
                 END


                                                                        163





               END IF
            ELSE
               PRINT "SORRY...NO ACTIVE XMS MEMORY MANAGER FOUND"
               PRINT "MAKE SURE YOU HAVE A XMS MEMORY MANAGER (SUCH AS
            'HIMEM.SYS' INSTALLED)"
               END
            END IF
            IF WHICHVGA = 0 THEN
               PRINT "CAN'T ID VIDEO CARD"
               END
            END IF
            DUMMY = RES640
            DRWFILLBOX 1, 10, 0, 0, 200, 400
            FOR I = 0 TO 200
               X1 = RND * 200
               Y1 = RND * 400
               X2 = RND * 200
               Y2 = RND * 400
               C = RND * 16
               DRWLINE 1, C, X1, Y1, X2, Y2
            NEXT I
            DRWBOX 1, 15, 0, 0, 200, 400
            REM *ALLOCATE A BLOCK OF XMS MEMORY*
            OurHandle = XMSBLKGET(0, 0, 200, 400)
            IF OurHandle = 0 THEN
               DUMMY = RESTEXT
               DUMMY = XMSFREE(OurHandle)
               PRINT "OPPS..THERE IS SOME ERROR...UNABLE TO ALLOCATE XMS"
               END
            END IF
            ER = XMSBLKPUT(1, 175, 75, OurHandle)
            DUMMY = XMSFREE(OurHandle)
            WHILE INKEY$ = ""
            WEND
            DUMMY = RESTEXT
            END




















                                                                        164





          XMSBLKPUT

            PROTOTYPE

            FUNCTION XMSBLKPUT (Mode%, X%, Y%, SrcXmsHandle%)

            INPUT

            Mode - pixel write mode (set=1, xor=2, or=3, and=4)
            X, Y - location for top left corner of block
            SrcXmsHandle - handle of source extended memory block

            OUTPUT

            Used as a function, XMSBLKPUT returns a 1 if successful, 0
            otherwise.

            USAGE

            XMSBLKPUT places the pixel data contained in XMS memory
            referenced by SrcXmsHandle on the screen.  The top, left
            corner of the block is specified by (x, y).  Any (x, y) is
            acceptable and any portion of the block that lies outside of
            the currently defined viewport will not be drawn.  If the
            function was unseccessful, check XMSERROR for error codes.

            All allocated XMS blocks must be freed using XMSFREE before a
            program terminates or the memory is lost until the machine is
            rebooted.  Simply exiting a program will not free allocated
            extended memory blocks.

            SEE ALSO

            XMSBLKGET, XMSERROR, XMSFREE, XMSSCREENGET, XMSSCREENPUT

            EXAMPLE

            See XMSBLKGET


















                                                                        165





          XMSCOPY

            PROTOTYPE

            FUNCTION XMSCOPY% (SrcXmsHandle%, SrcOffset&, DestXmsHandle%,
            DestOffset&, NumBytes&)

            INPUT

            SrcXmsHandle - handle of source extended memory block
            SrcOffset - number of bytes from beginning of source memory
            block
            DestXmsHandle - handle of destination extended memory block
            DestOffset - number of bytes from beginning of destination
            memory block
            NumBytes - number of bytes to copy from source to destination
            (must be even)

            OUTPUT

            XMSCOPY returns a 1 if copy was successful, 0 otherwise.

            USAGE

            XMSCOPY copies the number of bytes specified in NumBytes from
            the source extended memory block to the destination extended
            memory block.  NumBytes must be an even number.  The copy may
            begin and/or end offset from the beginning of the source and
            destination blocks by passing non zero values in SrcOffset
            and/or DestOffset.  The copy will occur faster if both offsets
            are divisible by four.  If the copy was unsuccessful, check
            XMSERROR for error codes.

            SEE ALSO

            WHICHXMS, XMSALLOCATE, XMSERROR, XMSFREE, XMSGET, XMSPUT

            EXAMPLE

            REM THIS WILL COPY ONE ARRAY INTO ONE XMS BLOCK AND THEN COPY
            IT
            REM TO A DIFFERENT XMS BLOCK, AND THEN COPY THAT BACK INTO
            ANOTHER ARRAY
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            REM *DIMENSION OUR SOURCE AND DESTINATION ARRAYS*
            DIM TEST1(0 TO 9) AS INTEGER
            DIM TEST2(0 TO 9) AS INTEGER
            CLS

            REM *MAKE SURE XMS IS READY AND AVAILBLE*
            IF WHICHXMS(MEM, HANDLES) = 1 THEN
               IF MEM < 1 OR HANDLES < 1 THEN


                                                                        166





                 PRINT "SORRY...THERE IS EITHER NO FREE XMS MEMORY OR NO
            FREE XMS HANDLES"
                 END
               END IF
            ELSE
               PRINT "SORRY...NO ACTIVE XMS MEMORY MANAGER FOUND"
               PRINT "MAKE SURE YOU HAVE A XMS MEMORY MANAGER (SUCH AS
            'HIMEM.SYS' INSTALLED)"
               END
            END IF

            REM *PUT SOME DATA INTO THE SOURCE ARRAY*
            FOR I = 0 TO 9
               TEST1(I) = I * 10
            NEXT I

            REM *ALLOCATE THE FIRST XMS MEMORY BLOCK*
            OurHandle1 = XMSALLOCATE(1)
            IF OurHandle1 = 0 THEN
               PRINT "OPPS..THERE IS SOME ERROR...UNABLE TO ALLOCATE XMS"
               PRINT "ERROR #"; XMSERROR
               ER = XMSFREE(OurHandle1)
               END
            END IF

            REM *ALLOCATE THE SECOND XMS MEMORY BLOCK*
            OurHandle2 = XMSALLOCATE(1)
            IF OurHandle2 = 0 THEN
               PRINT "OPPS..THERE IS SOME ERROR...UNABLE TO ALLOCATE XMS"
               PRINT "ERROR #"; XMSERROR
               ER = XMSFREE(OurHandle1)
               ER = XMSFREE(OurHandle2)
               END
            END IF

            REM *COPY OUR SOURCE ARRAY INTO OUR FIRST XMS BLOCK*
            I = XMSPUT(TEST1(0), OurHandle1, 0, 20)
            IF I = 0 THEN
               PRINT "OPPS..THERE IS SOME ERROR...SEE THE ERROR CODE
            LIST..."
               PRINT "ERROR #"; XMSERROR
               ER = XMSFREE(OurHandle1)
               ER = XMSFREE(OurHandle2)
               END
            END IF

            REM *COPY THE FIRST XMS BLOCK TO THE SECOND XMS BLOCK*
            IF XMSCOPY(OurHandle1, 0, OurHandle2, 0, 20) = 0 THEN
               PRINT "OPPS..THERE IS SOME ERROR...SEE THE ERROR CODE
            LIST..."
               PRINT "ERROR #"; XMSERROR
               ER = XMSFREE(OurHandle1)
               ER = XMSFREE(OurHandle2)
               END


                                                                        167





            END IF

            REM *COPY DATA FROM THE SECOND XMS BLOCK TO OUR DESTINATION
            ARRAY*
            IF XMSGET(OurHandle2, 0, TEST2(0), 20) = 0 THEN
               PRINT "OPPS..THERE IS SOME ERROR...SEE THE ERROR CODE
            LIST..."
               PRINT "ERROR #"; ER
               ER = XMSFREE(OurHandle1)
               ER = XMSFREE(OurHandle2)
               END
            END IF

            REM *FREE THE XMS BLOCKS WE HAVE ALLOCATED*
            ER = XMSFREE(OurHandle1)
            ER = XMSFREE(OurHandle2)

            REM *SHOW THE RESULTS*
            PRINT "OK...WE INITILIZED ONE ARRAY,PUT A COPY OF IT INTO
            XMS,"
            PRINT "THEN WE COPIED THAT XMS BLOCK TO ANOTHER XMS BLOCK,
            AND"
            PRINT "THEN PUT A COPY OF THE SECOND XMS BLOCK INTO A NEW
            ARRAY;"
            PRINT "HERE ARE THE RESULTS:"
            PRINT
            PRINT "SOURCE ARRAY", , "DESTINATION ARRAY"
            FOR I = 0 TO 9
               PRINT TEST1(I), , TEST2(I)
            NEXT I
            END

























                                                                        168





          XMSERROR

            PROTOTYPE

            FUNCTION XMSERROR% ()

            INPUT

            no input parameters

            OUTPUT

            XMSERROR returns the error code from the most recent XMS
            function call.

            USAGE

            XMSERROR returns the error code from the most recent XMS
            function call.  Each XMS function resets the error code to
            zero.  Therefore, if there has been an error, the error code
            should be checked immediately.  The error code will be one of
            the following:

            0    no error
            1    WHICHXMS has not been
                 called
            2    number of bytes to
                 copy is zero
            3    number of bytes to
                 copy is odd
            4    offset into XMS block
                 is zero
            128  Function not
                 implemented
            129  VDISK device driver
                 was detected
            142  General driver error
            143  Unrecoverable driver
                 error
            146  DX is less than
                 /HMAMIN= parameter
            160  All extended memory is
                 allocated
            161  XMM handles are
                 exhausted
            162  Handle is invalid
            163  Source handle is
                 invalid
            164  Source offset is
                 invalid
            165  Destination handle is
                 invalid
            166  Destination offset is
                 invalid


                                                                        169





            167  Length is invalid
            168  Overlap in move
                 request is invalid
            169  Parity error detected
            171  Block locked

            SEE ALSO

            WHICHXMS, XMSALLOCATE, XMSBLKGET, XMSBLKPUT, XMSCOPY, XMSFREE,
            XMSGET, XMSPUT, XMSSCREENGET, XMSSCREENPUT

            EXAMPLE

            See XMSCOPY










































                                                                        170





          XMSFREE

            PROTOTYPE

            FUNCTION XMSFREE% (XmsHandle%)

            INPUT

            XmsHandle - handle of extended memory block to free

            OUTPUT

            XMSFREE returns 1 if extended memory block was deallocated, 0
            otherwise.

            USAGE

            XMSFREE deallocates the specified extended memory block.  All
            allocated blocks must be freed before a program terminates or
            the memory is lost until the machine is rebooted.  Simply
            exiting a program will not free allocated extended memory
            blocks.  If the function was unsuccessful, check XMSERROR for
            error codes.

            SEE ALSO

            WHICHXMS, XMSALLOCATE, XMSBLKGET, XMSBLKPUT, XMSCOPY,
            XMSERROR, XMSGET, XMSPUT, XMSSCREENGET, XMSSCREENPUT

            EXAMPLE

            See XMSCOPY
























                                                                        171





          XMSGET

            PROTOTYPE

            FUNCTION XMSGET% (SrcXmsHandle%, SrcOffset&, DestVariable%,
            NumBytes&)

            INPUT

            SrcXmsHandle - handle of source extended memory block
            SrcOffset - number of bytes from beginning of source memory
            block
            NumBytes - number of bytes to copy from extended memory to
            conventional memory (must be even)

            OUTPUT

            XMSGET returns 0 if the copy was successful, an error code
            otherwise.
            DestVariable - integer variable or array holding copied data

            USAGE

            XMSGET retrieves data from extended memory and places it in
            conventional memory.  The number of bytes copied must be an
            even number and cannot be larger than 65536.  The copy may
            begin off the beginning of the source extended memory block by
            specifying a non zero SrcOffset.  If the function was
            unsuccessful, check XMSERROR for error codes.

            SEE ALSO

            WHICHXMS, XMSALLOCATE, XMSCOPY, XMSERROR, XMSFREE, XMSPUT

            EXAMPLE

            See XMSCOPY



















                                                                        172





          XMSPUT

            PROTOTYPE

            FUNCTION XMSPUT% (SrcVariable%, DestXmsHandle%, DestOffset&,
            NumBytes&)

            INPUT

            SrcVariable - source variable or array in conventional memory
            DestXmsHandle - handle of destination extended memory block
            DestOffset - number of bytes from beginning of destination
            memory block
            NumBytes - number of bytes to copy from conventional memory to
            extended memory (must be even)

            OUTPUT

            XMSPUT returns 1 if the copy was successful, 0 otherwise.

            USAGE

            XMSPUT copies data from conventional memory to extended
            memory.  The number of bytes copied must be an even number and
            cannot be larger than 65536.  The destination may begin off
            the beginning of the extended memory block by specifying a non
            zero DestOffset.  If the function was unsuccessful, check
            XMSERROR for error codes.

            SEE ALSO

            WHICHXMS, XMSALLOCATE, XMSCOPY, XMSERROR, XMSFREE, XMSGET

            EXAMPLE

            See XMSCOPY




















                                                                        173





          XMSSCREENGET

            PROTOTYPE

            FUNCTION XMSSCREENGET ( )

            INPUT

            no input parameters

            OUTPUT

            Used as a function, XMSSCREENGET returns the assigned XMS
            memory handle if successful, 0 if it otherwise.

            USAGE

            XMSSCREENGET stores the pixel data contained within the entire
            active screen.  The bitmap is stored such that the first
            integer in the allocated XMS block is the width and the second
            integer is the height.  These are followed by a long integer
            (4 bytes) that specifies the total size of the allocated XMS
            block.  The remaining bytes are the bitmap raster data stored
            by rows starting at the top of the screen.  Note that this
            function is about twice as fast as using XMSBLKGET to save the
            entire screen.  If the function was unseccessful, check
            XMSERROR for error codes.

            All allocated XMS blocks must be freed using XMSFREE before a
            program terminates or the memory is lost until the machine is
            rebooted.  Simply exiting a program will not free allocated
            extended memory blocks.

            SEE ALSO

            XMSBLKGET, XMSBLKPUT, XMSERROR, XMSFREE, XMSSCREENPUT

            EXAMPLE

            REM THIS WILL SAVE THE ENTIRE SCREEN IN XMS MSMORY
            REM $INCLUDE: 'SVGABC.BI'
            DEFINT A-Z

            CLS
            IF WHICHXMS(MEM, HANDLES) = 1 THEN
               IF MEM < 1 OR HANDLES < 1 THEN
                 PRINT "SORRY...THERE IS EITHER NO FREE XMS MEMORY OR NO
            FREE XMS HANDLES"
                 END
               END IF
            ELSE
               PRINT "SORRY...NO ACTIVE XMS MEMORY MANAGER FOUND"
               PRINT "MAKE SURE YOU HAVE A XMS MEMORY MANAGER (SUCH AS
            'HIMEM.SYS' INSTALLED)"


                                                                        174





               END
            END IF
            IF WHICHVGA = 0 THEN
               PRINT "CAN'T ID VIDEO CARD"
               END
            END IF
            DUMMY = RES640
            DRWFILLBOX 1, 10, 0, 0, GETMAXX, GETMAXY
            FOR I = 0 TO 200
               X1 = RND * GETMAXX
               Y1 = RND * GETMAXY
               X2 = RND * GETMAXX
               Y2 = RND * GETMAXY
               C = RND * 16
               DRWLINE 1, C, X1, Y1, X2, Y2
            NEXT I
            DRWBOX 1, 15, 0, 0, GETMAXX, GETMAXY
            REM *ALLOCATE A BLOCK OF XMS MEMORY*
            OurHandle = XMSSCREENGET
            IF OurHandle = 0 THEN
               DUMMY = RESTEXT
               DUMMY = XMSFREE(OurHandle)
               PRINT "OPPS..THERE IS SOME ERROR...UNABLE TO ALLOCATE XMS"
               END
            END IF
            FILLSCREEN 0
            DRWSTRING 1, 10, 0, "PRESS A KEY...", 0, 0
            WHILE INKEY$ = ""
            WEND
            ER = XMSSCREENPUT(OurHandle)
            DUMMY = XMSFREE(OurHandle)
            WHILE INKEY$ = ""
            WEND
            DUMMY = RESTEXT
            END





















                                                                        175





          XMSSCREENPUT

            PROTOTYPE

            FUNCTION XMSSCREENPUT (SrcXmsHandle%)

            INPUT

            SrcXmsHandle - handle of source extended memory block

            OUTPUT

            Used as a function, XMSSCREENPUT returns a 1 if successful, 0
            otherwise.

            USAGE

            XMSSCREENPUT places the complete screen pixel data contained
            in xms memory referenced by SrcXmsHandle on the screen.  The
            current screen resolution must be the same as the saved screen
            resolution. this function is not bound by the current
            viewport.  If the function was unseccessful, check XMSERROR
            for error codes.

            SEE ALSO

            XMSBLKGET, XMSBLKPUT, XMSERROR, XMSFREE, XMSSCREENPUT

            EXAMPLE

            See XMSSCREENGET

























                                                                        176





          APPENDIX A.  SVGABC.BI

          This is the header file containing function declarations and
          structure definitions for SVGAQB.LIB and SVGAPV.LIB.  This file
          should be included in every program that uses this library.  To
          properly include the header file, place the following line at the
          top of the every program module:

                              REM $INCLUDE: 'SVGABC.BI'

          Without these declarations and definitions, the compiler will be
          unable to compile any program using the commands found in this
          library.

          REM SVGAQB,SVGAPV GRAPHICS LIBRARY INCLUDE FILE FOR MS QuickBasic
          4.5,
          REM MS PDS and MS VBDOS
          REM COPYRIGHT 1993-1995 BY STEPHEN L. BALKUM AND DANIEL A. SILL
          REM ZEPHYR SOFTWARE P.O. BOX 7704, AUSTIN, TEXAS  78713-7704
          REM LAST UPDATE 1/1/95

          TYPE P2DType
            X AS INTEGER
            Y AS INTEGER
          END TYPE

          TYPE P3Dtype
            X AS INTEGER
            Y AS INTEGER
            Z AS INTEGER
          END TYPE

          TYPE PROJType
            EYEX AS INTEGER
            EYEY AS INTEGER
            EYEZ AS INTEGER
            SCRD AS INTEGER
            THETA AS INTEGER
            PHI AS INTEGER
          END TYPE

          DECLARE SUB BLKGET (BYVAL X1%, BYVAL Y1%, BYVAL X2%, BYVAL Y2%,
          SEG GfxBlk%)
          DECLARE SUB BLKPUT (BYVAL Mode%, BYVAL X%, BYVAL Y%, SEG GfxBlk%)
          DECLARE SUB BLKRESIZE (BYVAL X%, BYVAL Y%, SEG SourceGfxBlk%, SEG
          DestGfxBlk%)
          DECLARE FUNCTION BLKROTATE% (BYVAL Ang%, BYVAL BackFill%, SEG
          SourceGfxBlk%, SEG DestGfxBlk%)
          DECLARE FUNCTION BLKROTATESIZE& (BYVAL Ang%, SEG SourceGfxBlk%)
          DECLARE SUB BYTECOPY (SEG SourceArray%, SEG DestArray%, BYVAL
          NumOfBytes&)
          DECLARE SUB D2ROTATE (BYVAL Points%, BYVAL XOrigin%, BYVAL
          YOrigin%, BYVAL Ang%, SEG InAry%, SEG OutAry%)



                                                                        177





          DECLARE SUB D2SCALE (BYVAL Points%, BYVAL XSCALE%, BYVAL YSCALE%,
          SEG InAry%, SEG OutAry%)
          DECLARE SUB D2TRANSLATE (BYVAL Points%, BYVAL XTRANS%, BYVAL
          YTRANS%, SEG InAry%, SEG OutAry%)
          DECLARE FUNCTION D3PROJECT% (BYVAL Points%, SEG ProjParms%, SEG
          InAry%, SEG OutAry%)
          DECLARE SUB D3ROTATE (BYVAL Points%, BYVAL XOrigin%, BYVAL
          YOrigin%, BYVAL ZOrigin%, BYVAL ZRAng%, BYVAL YRAng%, BYVAL
          XRAng%, SEG InAry%, SEG OutAry%)
          DECLARE SUB D3SCALE (BYVAL Points%, BYVAL XSCALE%, BYVAL YSCALE%,
          BYVAL ZScale%, SEG InAry%, SEG OutAry%)
          DECLARE SUB D3TRANSLATE (BYVAL Points%, BYVAL XTRANS%, BYVAL
          YTRANS%, BYVAL ZTrans%, SEG InAry%, SEG OutAry%)
          DECLARE SUB DRWALINE (BYVAL ColrBits%, BYVAL Colr%, BYVAL X1%,
          BYVAL Y1%, BYVAL X2%, BYVAL Y2%)
          DECLARE SUB DRWBOX (BYVAL Mode%, BYVAL Colr%, BYVAL X1%, BYVAL
          Y1%, BYVAL X2%, BYVAL Y2%)
          DECLARE SUB DRWCIRARC (BYVAL Mode%, BYVAL Colr%, BYVAL CenterX%,
          BYVAL CenterY%, BYVAL Radius%, BYVAL StartAng&, BYVAL EndAng&)
          DECLARE SUB DRWCIRCLE (BYVAL Mode%, BYVAL Colr%, BYVAL CenterX%,
          BYVAL CenterY%, BYVAL Radius%)
          DECLARE SUB DRWCUBICBEZIER (BYVAL Mode%, BYVAL Colr%, SEG Pon1%,
          SEG Poff1%, SEG Poff2%, SEG Pon2%)
          DECLARE SUB DRWELLARC (BYVAL Mode%, BYVAL Colr%, BYVAL CenterX%,
          BYVAL CenterY%, BYVAL RadiusX%, BYVAL RadiusY%, BYVAL StartAng&,
          BYVAL EndAng&)
          DECLARE SUB DRWELLIPSE (BYVAL Mode%, BYVAL Colr%, BYVAL CenterX%,
          BYVAL CenterY%, BYVAL RadiusX%, BYVAL RadiusY%)
          DECLARE SUB DRWFILLBOX (BYVAL Mode%, BYVAL Colr%, BYVAL X1%,
          BYVAL Y1%, BYVAL X2%, BYVAL Y2%)
          DECLARE SUB DRWFILLCIRCLE (BYVAL Mode%, BYVAL Colr%, BYVAL
          CenterX%, BYVAL CenterY%, BYVAL Radius%)
          DECLARE SUB DRWFILLELLIPSE (BYVAL Mode%, BYVAL Colr%, BYVAL
          CenterX%, BYVAL CenterY%, BYVAL RadiusX%, BYVAL RadiusY%)
          DECLARE SUB DRWLINE (BYVAL Mode%, BYVAL Colr%, BYVAL X1%, BYVAL
          Y1%, BYVAL X2%, BYVAL Y2%)
          DECLARE SUB DRWPOINT (BYVAL Mode%, BYVAL Colr%, BYVAL X%, BYVAL
          Y%)
          DECLARE SUB DRWRCIRARC (BYVAL Mode%, BYVAL Colr%, BYVAL CenterX%,
          BYVAL CenterY%, BYVAL Radius%, BYVAL StartAng!, BYVAL EndAng!)
          DECLARE SUB DRWRELLARC (BYVAL Mode%, BYVAL Colr%, BYVAL CenterX%,
          BYVAL CenterY%, BYVAL RadiusX%, BYVAL RadiusY%, BYVAL StartAng!,
          BYVAL EndAng!)
          DECLARE SUB DRWSTRING (BYVAL Mode%, BYVAL FColr%, BYVAL BColr%,
          Strng$, BYVAL X%, BYVAL Y%)
          DECLARE SUB DRWSTRINGDN (BYVAL Mode%, BYVAL FColr%, BYVAL BColr%,
          Strng$, BYVAL X%, BYVAL Y%)
          DECLARE SUB DRWSTRINGLT (BYVAL Mode%, BYVAL FColr%, BYVAL BColr%,
          Strng$, BYVAL X%, BYVAL Y%)
          DECLARE SUB DRWSTRINGRT (BYVAL Mode%, BYVAL FColr%, BYVAL BColr%,
          Strng$, BYVAL X%, BYVAL Y%)
          DECLARE SUB FILLAREA (BYVAL Xseed%, BYVAL Yseed%, BYVAL
          BorderColr%, BYVAL FillColr%)



                                                                        178





          DECLARE SUB FILLCOLOR (BYVAL Xseed%, BYVAL Yseed%, BYVAL
          OldColr%, BYVAL NewColr%)
          DECLARE SUB FILLCONVEXPOLY (BYVAL Colr%, BYVAL Points%, SEG
          InAry%)
          DECLARE SUB FILLPOLY (BYVAL Colr%, BYVAL Points%, SEG InAry%)
          DECLARE SUB FILLSCREEN (BYVAL Colr%)
          DECLARE SUB FILLPAGE (BYVAL Colr%)
          DECLARE SUB FILLVIEW (BYVAL Colr%)
          DECLARE SUB FONTGETINFO (SEG WDTH%, SEG HGHT%)
          DECLARE SUB FONTSET (FONT$)
          DECLARE SUB FONTSYSTEM ()
          DECLARE FUNCTION GETARCCOS% (BYVAL Value&)
          DECLARE FUNCTION GETARCSIN% (BYVAL Value&)
          DECLARE FUNCTION GETARCTAN% (BYVAL Value&)
          DECLARE FUNCTION GETCOS& (BYVAL Ang&)
          DECLARE FUNCTION GETSIN& (BYVAL Ang&)
          DECLARE FUNCTION GETTAN& (BYVAL Ang&)
          DECLARE FUNCTION GETSQRT& (BYVAL Number&)
          DECLARE FUNCTION GETMAXX% ()
          DECLARE FUNCTION GETMAXY% ()
          DECLARE SUB GETLASTSTRING (SEG StrngGfxBlk%)
          DECLARE FUNCTION GETPOINT% (BYVAL X%, BYVAL Y%)
          DECLARE SUB JOYSTICKINFO (SEG JAX%, SEG JAY%, SEG JAButs%, SEG
          JBX%, SEG JBY%, SEG JBButs%)
          DECLARE SUB MOUSEBUTPRESS (BYVAL ReqBut%, SEG Xloc%, SEG Yloc%,
          SEG Num%, SEG MButs%)
          DECLARE SUB MOUSEBUTRELEASE (BYVAL ReqBut%, SEG Xloc%, SEG Yloc%,
          SEG Num%, SEG MButs%)
          DECLARE SUB MOUSECURSORDEFAULT ()
          DECLARE SUB MOUSECURSORSET (MouseCursor$)
          DECLARE SUB MOUSEENTER ()
          DECLARE SUB MOUSEEXIT ()
          DECLARE SUB MOUSEHIDE ()
          DECLARE SUB MOUSEINFO (SEG DrvMajorVer%, SEG DrvMinorVer%, SEG
          MouseType%, SEG IRQnumber%)
          DECLARE SUB MOUSELOCSET (BYVAL Xloc%, BYVAL Yloc%)
          DECLARE SUB MOUSERANGESET (BYVAL X1%, BYVAL Y1%, BYVAL X2%, BYVAL
          Y2%)
          DECLARE SUB MOUSERESTORESTATE (SEG MouseBuf%)
          DECLARE SUB MOUSESAVESTATE (SEG MouseBuf%)
          DECLARE SUB MOUSESENSSET (BYVAL Xsens%, BYVAL Ysens%)
          DECLARE SUB MOUSESHOW ()
          DECLARE SUB MOUSESTATUS (SEG X%, SEG Y%, SEG MButs%)
          DECLARE FUNCTION MOUSESTORAGESIZE% ()
          DECLARE SUB OVERSCANSET (BYVAL Colr%)
          DECLARE FUNCTION PAGEDISPLAY% (BYVAL X%, BYVAL Y%, BYVAL Page%)
          DECLARE FUNCTION PAGEACTIVE% (BYVAL Page%)
          DECLARE SUB PALCHGAUTO (PalString$, NewPalString$, BYVAL
          FirstColr%, BYVAL LastColr%, BYVAL Speed%)
          DECLARE SUB PALCHGSTEP (PalString$, NewPalString$, BYVAL
          FirstColr%, BYVAL LastColr%, BYVAL Percent%)
          DECLARE SUB PALCOPY (SourcePalString$, DestPalString$, BYVAL
          FirstColr%, BYVAL LastColr%)



                                                                        179





          DECLARE SUB PALDIMSTEP (PalString$, BYVAL FirstColr%, BYVAL
          LastColr%, BYVAL Percent%)
          DECLARE SUB PALGET (PalString$, BYVAL FirstColr%, BYVAL
          LastColr%)
          DECLARE SUB PALIOAUTO (PalString$, BYVAL FirstColr%, BYVAL
          LastColr%, BYVAL Speed%)
          DECLARE SUB PALROTATE (PalString$, BYVAL FirstColr%, BYVAL
          LastColr%, BYVAL Shift%)
          DECLARE SUB PALSET (PalString$, BYVAL FirstColr%, BYVAL
          LastColr%)
          DECLARE FUNCTION PCXMAKE% (BYVAL X1%, BYVAL Y1%, BYVAL X2%, BYVAL
          Y2%, FileName$)
          DECLARE FUNCTION PCXGETINFO% (FileName$, SEG PCXXSize%, SEG
          PCXYSize%, SEG NumColors%, Pal$)
          DECLARE FUNCTION PCXPUT% (BYVAL Mode%, BYVAL Xloc%, BYVAL Yloc%,
          Name$)
          DECLARE FUNCTION RES320% ()
          DECLARE FUNCTION RES640L% ()
          DECLARE FUNCTION RES640% ()
          DECLARE FUNCTION RES800% ()
          DECLARE FUNCTION RES1024% ()
          DECLARE FUNCTION RES1280% ()
          DECLARE FUNCTION RESTEXT% ()
          DECLARE SUB SCROLLDN (BYVAL X1%, BYVAL Y1%, BYVAL X2%, BYVAL Y2%,
          BYVAL Num%, BYVAL Colr%)
          DECLARE SUB SCROLLLT (BYVAL X1%, BYVAL Y1%, BYVAL X2%, BYVAL Y2%,
          BYVAL Num%, BYVAL Colr%)
          DECLARE SUB SCROLLRT (BYVAL X1%, BYVAL Y1%, BYVAL X2%, BYVAL Y2%,
          BYVAL Num%, BYVAL Colr%)
          DECLARE SUB SCROLLUP (BYVAL X1%, BYVAL Y1%, BYVAL X2%, BYVAL Y2%,
          BYVAL Num%, BYVAL Colr%)
          DECLARE SUB SDELAY (BYVAL Count%)
          DECLARE SUB SETCARD (BYVAL CHIP%, BYVAL MEM%)
          DECLARE SUB SETVIEW (BYVAL X1%, BYVAL Y1%, BYVAL X2%, BYVAL Y2%)
          DECLARE SUB SPRITEGAP (BYVAL TransColr%, BYVAL X%, BYVAL Y%, SEG
          SpriteGfxBlk%, SEG BkgndGfxBlk%)
          DECLARE SUB SPRITEGET (BYVAL TransColr%, BYVAL X%, BYVAL Y%, SEG
          SpriteGfxBlk%, SEG BkgndGfxBlk%)
          DECLARE SUB SPRITEPUT (BYVAL Mode%, BYVAL TransColr%, BYVAL X%,
          BYVAL Y%, SEG SpriteGfxBlk%)
          DECLARE FUNCTION SPRITECOLLDETECT% (BYVAL TransColr%, BYVAL
          Sprite1LocX%, BYVAL Sprite1LocY%, BYVAL Sprite2LocX%, BYVAL
          Sprite2LocY%, SEG Sprite1GfxBlk%, SEG Sprite2GfxBlk%)
          DECLARE FUNCTION VIDEOMODEGET% ()
          DECLARE SUB VIDEOMODESET (BYVAL Mode%)
          DECLARE SUB VIDEOOFF ()
          DECLARE SUB VIDEOON ()
          DECLARE FUNCTION WHICHCPU% ()
          DECLARE FUNCTION WHICHJOYSTICK% ()
          DECLARE FUNCTION WHICHMEM% ()
          DECLARE FUNCTION WHICHMOUSE% ()
          DECLARE FUNCTION WHICHVGA% ()
          DECLARE FUNCTION WHICHXMS% (SEG XmsKbytesAvailable%, SEG
          XmsHandlesAvailable%)


                                                                        180





          DECLARE FUNCTION XMSALLOCATE% (BYVAL ReqKbytesOfMem%)
          DECLARE FUNCTION XMSBLKGET% (BYVAL X1%, BYVAL Y1%, BYVAL X2%,
          BYVAL Y2%)
          DECLARE FUNCTION XMSBLKPUT% (BYVAL Mode%, BYVAL X%, BYVAL Y%,
          BYVAL XmsHandle%)
          DECLARE FUNCTION XMSCOPY% (BYVAL XmsHandle1%, BYVAL
          OffsetIntoXms1&, BYVAL XmsHandle2%, BYVAL OffsetIntoXms2&, BYVAL
          NumOfBytes&)
          DECLARE FUNCTION XMSERROR% ()
          DECLARE FUNCTION XMSFREE% (BYVAL XmsHandle%)
          DECLARE FUNCTION XMSGET% (BYVAL XmsHandle%, BYVAL OffsetIntoXms&,
          SEG DestVar%, BYVAL NumOfBytes&)
          DECLARE FUNCTION XMSPUT% (SEG SourceVar%, BYVAL XmsHandle%, BYVAL
          OffsetIntoXms&, BYVAL NumOfBytes&)
          DECLARE FUNCTION XMSSCREENGET% ()
          DECLARE FUNCTION XMSSCREENPUT% (BYVAL XmsHandle%)








































                                                                        181





          APPENDIX B.  JOYSTICK PORTS AND Y-CABLES

          SCHEMATIC WIRING DIAGRAM FOR A STANDARD JOYSTICK PORT

                                    DB15 male
                                    connector
                   Joystick B            ___       Joystick A
                                      __/   |
                                     /    o | 1 -------------------+
             +------------------  9 | o     |     ___Button A      |
             |     Button A___      |     o | 2 --o o-+            |
             |           +-o o-- 10 | o     |         |    X Axis  |
             |  X Axis   |          |     o | 3 -------------+     |
             |     +------------ 11 | o     |         |      |     |
             |     |     |          |     o | 4 ------+      |     |
             +--/\/\/\   +------ 12 | o     |         |    /\/\/\--+
             |           |          |     o | 5       |            |
             |     +------------ 13 | o     |         |            |
             |     |     | ___      |     o | 6 -------------+     |
             |     |     +-o o-- 14 | o     |     ___ |      |     |
             |     |    Button B    |     o | 7 --o o-+      |     |
             |     |             15 | o     |   Button B   /\/\/\--+
             +--/\/\/\               \__  o | 8            Y Axis
               Y Axis                   \___|


          Notes:

          1)This diagram comes with NO warranties expressed or implied.
            It is provided for information only.  In no event shall
            Stephen L. Balkum, Daniel A. Sill or Zephyr Software be held
            liable for damages resulting from use, misuse, or inability to
            use this information.

          2)The x and y axis potentiometers have a typical range of 0 to
            100k ohms.  Buttons are normally open and close when pressed.

          3)This diagram is correct for joystick ports that conform to the
            standard set forth by IBM. Some specialty joystick cards
            provide separate A and B joystick connectors.  For these
            cards, both connectors are wired to pins 1 through 8 as shown
            in the diagram.

          4)Many 'Super I/O' boards (2H/2F/2S/1P/1G) equipped with a
            joystick port will support only one joystick.  On these cards,
            pins 9 through 15 are not used.

          5)Commercially available joysticks are wired to use pins 1
            through 8 and, therefore, will always be 'Joystick A' if
            plugged directly into a dual joystick port connector.

          6)Many sound cards provide joystick ports; however, their
            connector wiring does not always conform to the standard shown
            above.  Some of these connectors may be used for other


                                                                        182





            purposes such as a MIDI port.  See the documentation that
            comes with the sound card.

          7)If there is more than one joystick port on a computer
            configured to operate the same joystick, only ONE port should
            be enabled at any given time for proper operation.  Disable
            all but one joystick port.  For example, if the computer has
            both a Super I/O card and a sound card, the joystick port on
            the Super I/O card should be disabled since the sound card's
            port probably supports two joysticks and the I/O card supports
            only one.













































                                                                        183





          SCHEMATIC WIRING DIAGRAM FOR A JOYSTICK Y-CABLE

                                              ___
                         DB15 male         __/   |
                       connector to       /    o | 1 --------+
                       Joystick Port   9 | o     |           |
                        on computer      |     o | 2 --------|-+
                            +-------- 10 | o     |           | |
                            |            |     o | 3 --------|-|-+
                            | +------ 11 | o     |           | | |
                            | |          |     o | 4 --------|-|-|-+
                            | |       12 | o     |           | | | |
                            | |          |     o | 5         | | | |
                            | | +---- 13 | o     |           | | | |
                            | | |        |     o | 6 --------|-|-|-|-+
                            | | | +-- 14 | o     |           | | | | |
                            | | | |      |     o | 7 --------|-|-|-|-|-+
                            | | | |   15 | o     |           | | | | | |
                            | | | |       \__  o | 8         | | | | | |
                            | | | |          \___|           | | | | | |
                            | | | |                          | | | | | |
                            | | | |                          | | | | | |
                            | | | |  +-----------------------+ | | | | |
                            | | | |  |                       | | | | | |
                            | | | |  | +---------------------|-|-|-+ | |
                            | | | |  | |                     | | | | | |
                            | | | |  | |                     | | | | | |
           DB15 female      | | | |  | |     DB15 female     | | | | | |
           connector to     | | | |  | |     connector to    | | | | | |
            Joystick B      | | | |  | |      Joystick A     | | | | | |
                  ___       | | | |  | |            ___      | | | | | |
               __/   |      | | | |  | |         __/   |     | | | | | |
              /    o | 1 ---|-|-|-|--+ |        /    o | 1 --+ | | | | |
           9 | o     |      | | | |    |     9 | o     |       | | | | |
             |     o | 2 ---+ | | |    |       |     o | 2 ----+ | | | |
          10 | o     |        | | |    |    10 | o     |         | | | |
             |     o | 3 -----+ | |    |       |     o | 3 ------+ | | |
          11 | o     |          | |    |    11 | o     |           | | |
             |     o | 4 -------|-|----+       |     o | 4 --------+ | |
          12 | o     |          | |         12 | o     |             | |
             |     o | 5        | |            |     o | 5           | |
          13 | o     |          | |         13 | o     |             | |
             |     o | 6 -------+ |            |     o | 6 ----------+ |
          14 | o     |            |         14 | o     |               |
             |     o | 7 ---------+            |     o | 7 ------------+
          15 | o     |                      15 | o     |
              \__  o | 8                        \__  o | 8
                 \___|                             \___|


          Notes:

          1)This diagram comes with NO warranties expressed or implied.
            It is provided for information only.  In no event shall


                                                                        184





            Stephen L. Balkum, Daniel A. Sill or Zephyr Software be held
            liable for damages resulting from use, misuse, or inability to
            use this information.

          2)This cable has worked with a standard joystick port connector,
            a Sound Blaster port connector, and a Sound Blaster Pro
            joystick port connector.

















































                                                                        185
 