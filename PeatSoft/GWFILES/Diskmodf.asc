100 'diskmodf v1.2
110 GOTO 280
140 '
150 ' The following are the slow subroutines which might be converted to ASM
160 COLOR 7,0
170 BM24=BYTE MOD 24:LOCATE BYTE\24+2,BM24*2+1:PRINT HX$(CHAR);:LOCATE ,BM24+51:PRINT AS$(CHAR);:RETURN
180 LOCATE 24,21:PRINT Z;"  ";:RETURN
190 LOCATE 1,42:PRINT BYTE:CHAR=PEEK(BUF+BYTE):LOCATE 24,35:PRINT CHAR;" ";:RETURN
280 CLEAR ,&H4B00:KEY OFF
300 DEFINT A-Z
390 DATA &h55
400 DATA &h8b,&hec
420 DATA &hbb,&h00
430 DATA &h4c,&h8b,&h76,&h06,&h8b
440 DATA &h0c,&h8b,&h76,&h08,&h8b
445 DATA &h14,&h8b,&h76,&h0a,&h8b,&h04,&h8a,&he0,&hb0,&h01
450 DATA &hcd,&h13,&h8a,&hc4,&hb4,&h00,&h89,&h04,&h5d
460 DATA &hca,&h06,&h00
500 INT13=&H4B00:FOR I=INT13 TO INT13+36:READ J:POKE I,J:NEXT I
505 BUF=&H4C00
512 DATA &h8b,&hdc,&hb4,&h08,&hcd,&h21,&h84,&hc0,&h74,&hf8,&h32,&he4,&h8b,&h5f,&h04,&h89,&h07,&hca,&h02,&h00
514 IN=&H4B80:FOR I=IN TO IN+19:READ J:POKE I,J:NEXT I
515 CLS:COLOR 7,0:LOCATE 12,13
517 PRINT "DiskModf V1.2 - Disk sector viewing and modification"
518 LOCATE 15,7:PRINT "Improved by Hal Sampson from original program by John Vandegrift"
520 DIM HX$(255):DIM AS$(255)
530 FOR I=0 TO 255:HX$(I)=RIGHT$("0"+HEX$(I),2):AS$(I)=CHR$(I):NEXT I
540 FOR I=7 TO 13:AS$(I)=CHR$(I+64):NEXT I
550 AS$(28)="\":AS$(29)="]":AS$(30)=CHR$(24):AS$(31)=CHR$(25)
560 NOTREAD=1
570 GOSUB 910
650 CLS:LOCATE 2,37:PRINT"DiskModf"
660 IF NOTREAD THEN LOCATE 23,30:PRINT "Sector not declared!!":GOTO 690
670 LOCATE 23,30:IF NOSIDES=1 THEN PRINT "Single-sided diskette":GOTO 690
680 PRINT "Double-sided diskette"
690 LOCATE 10,30:PRINT "(S)elect diskette sector"
700 LOCATE 11,30:PRINT "(V)iew/alter sector"
710 LOCATE 12,30:PRINT "(W)rite sector back to diskette"
730 LOCATE 13,30:PRINT"(Q)uit"
740 LOCATE 16,30:PRINT "Choice?";
745 CALL IN(I):I=I AND &H5F
747 IF I=83 THEN GOSUB 910
748 IF I=86 THEN GOSUB 1210
749 IF I=87 THEN GOSUB 790
750 IF I=81 THEN STOP
770 GOTO 650
790 REM         Put Sector on diskette
860 IF NOTREAD THEN RETURN
865 PRINT:PRINT:PRINT "Are you sure you want to alter disk? [N]";
868 CALL IN(I): IF (I AND &H5F) <>89  THEN RETURN
870 OP=3
880 CALL INT13 (OP,HDDR,TRSC)
885 IF OP<>0 THEN PRINT " retry";:OP=0:CALL INT13(OP,HDDR,TRSC):GOTO 870
890 RETURN
910 '
960 CLS:LOCATE 2,37:PRINT"DiskModf"
970 LOCATE 10,10:INPUT "Select drive (A-D)";DRIVE$
975 IF DRIVE$="" THEN 970
980 DRIVE=(ASC(DRIVE$) AND &H5F)-&H41
1000 IF DRIVE <0 OR DRIVE >3 THEN 970
1010 HDDR=256+DRIVE:TRSC=1:TRIES=3:NOTREAD=1
1020 OP=2:CALL INT13 (OP,HDDR,TRSC) 'check for single/double sided
1040 IF OP = 0 THEN NOSIDES=HDDR/256 +1:GOTO 1080
1050 TRIES=TRIES-1:IF TRIES=0 THEN 1055 ELSE OP=0: CALL INT13(OP,HDDR,TRSC):GOTO 1020
1055 IF HDDR>255 THEN TRIES=3:HDDR=DRIVE:GOTO 1020
1060 LOCATE 15,10:INPUT "Diskette error. C/R to go on.";I
1080 LOCATE 11,10:INPUT "Select track (0-39)";TRACK
1090 IF TRACK<0 OR TRACK>39 THEN 1080
1100 LOCATE 12,10:INPUT "Select sector (1-8)";SECTOR
1110 IF SECTOR<1 OR SECTOR>8 THEN 1100
1120 HEAD=0:IF NOSIDES=1 THEN 1150
1130 LOCATE 13,10:INPUT "Select side (0-1)";HEAD
1140 IF HEAD<0 OR HEAD>1 THEN 1130
1150 LOCATE 20,10:PRINT "Inputs satisfactory [Y]?"
1160 I$=INKEY$:IF I$="" THEN 1160 ELSE IF I$="N" OR I$="n" THEN 960
1170 HDDR=(HEAD*256)+DRIVE:TRSC=(TRACK*256)+SECTOR
1180 OP=2:CALL INT13(OP,HDDR,TRSC)
1185 IF OP<>0 THEN PRINT " retry";CHR$(7):OP=0:CALL INT13(OP,HDDR,TRSC):GOTO 1180
1187 NOTREAD=0
1190 GOSUB 1210 'always display it
1200 RETURN
1210 '
1280 IF NOTREAD THEN RETURN
1290 CLS
1300 LOCATE 1,1:PRINT"Drive ";DRIVE$;"  Side";HEAD;" Track";TRACK TAB(28) "Sector";SECTOR;" Byte";0
1310 BYTE=0
1320 GOSUB 1630
1330 GOSUB 190
1340 LOCATE 24,1:PRINT "New Value (Decimal)";
1350 COLOR 0,7:LOCATE 25,1:FOR II=24 TO 27:PRINT CHR$(II);:NEXT
1360 PRINT " - Cursor    No.+C/R - new no.    X - eXit";
1370 COLOR 0,7:GOSUB 170:GOSUB 180
1380 CALL IN(A)
1390 IF A=13 THEN CHAR=Z:Z=0:GOSUB 160:GOSUB 1520:GOTO 1370
1400 GOSUB 160
1430 IF A=77 THEN IF BYTE<511 THEN BYTE=BYTE+1:GOTO 1475
1440 IF A=80 THEN IF BYTE<488 THEN BYTE=BYTE+24:GOTO 1475
1450 IF A=75 THEN IF BYTE>0 THEN BYTE=BYTE-1:GOTO 1475
1460 IF A=72 THEN IF BYTE>24 THEN BYTE=BYTE-24:GOTO 1475
1470 IF A=88 OR A=120 THEN RETURN
1475 GOSUB 190
1480 IF A<48 OR A>57 THEN 1370
1490 Z=Z*10+A-48
1500 IF Z>255 THEN Z=0
1510 GOTO 1370
1520 POKE (BUF+BYTE),CHAR
1530 IF BYTE<511 THEN BYTE=BYTE+1
1540 GOSUB 190
1550 RETURN
1630 LOCATE 2,1:FOR A=BUF TO BUF+511 STEP 24:FOR B=A TO A+23:PRINT HX$(PEEK(B));:NEXT B:PRINT TAB(51);:FOR B=A TO A+23:PRINT AS$(PEEK(B));:NEXT B:PRINT:NEXT A
1640 LOCATE 23,17:PRINT "                                ";:LOCATE 23,59:PRINT "                ";:RETURN
